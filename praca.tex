\documentclass[licencjacka]{pracamgr}

\usepackage{polski}
\usepackage[utf8]{inputenc}

% Dane magistranta:

\author{Autorzy}

\nralbumu{Albumy}

\title{Platforma integracji mikrousług}

\tytulang{Project}

\kierunek{Informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{mgr Michał Możdżonek\\
  ZUS\\
  }

% miesiąc i~rok:
\date{Listopad 2016}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.127. Ubezpieczenia społeczne}

% Słowa kluczowe:
\keywords{mikrousługi, SOA, trudne sprawy}

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  Potem dopiszemy.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Wprowadzenie} 
\addcontentsline{toc}{chapter}{Wprowadzenie}
Tutaj napiszemy jakiś wstęp, nie mam pojęcia o czym. Janusz mówi: ,,Wstęp (a czasem nie tylko wstęp): opis całego projektu, w naturalny sposób daje się tu wykorzystać fragmenty wizji. Dyskusja rozwiązań konkurencyjnych - w zależności od projektu: na świecie, w Polsce, w zamawiającej firmie - ze śladem w bibliografii. To może być część wstępu, może być też osobny rozdział. "

\section{Uwagi Janusza}
Główna część pracy. Jeden bądź kilka rozdziałów poświęconych osiągnięciom, problemom, sukcesom projektu. To jest to miejsce, gdzie należy się pochwalić tym, co Państwo osiągnęli. Jeśli Państwo się sami nie pochwalicie, nikt nigdy nie będzie wiedział ile pracy, pomysłowości i wysiłku kosztowało zrealizowanie projektu. Chwalić się można i należy różnymi rzeczami.

Osiągnięciami (projekt ma świetny interfejs; projekt jako pierwszy rozwiązuje jakiś problem; użytkownicy projektu są bardzo zadowoleni, a klient zawarł z Państwem umowę na przyszłość; Państwa firma właśnie wchodzi na New Connect; 10\% z pierwszych zarobionych milionów przeznaczyli Państwo na fundację wspierania UW; itp.).
Ciekawymi rozwiązaniami i dobrym kodem (projekt stworzono od początku do końca wg nowoczesnej metodologii; w projekcie użyto zaawansowanych narzędzi np. do recenzji kodu; projekt korzysta z nowoczesnych bibliotek; w projekcie zastosowano niebanalne algorytmy; projekt używa dedykowanego sprzętu; projekt korzysta z rozbudowanej infrastruktury: serwer WWW + serwer b.d. + serwer aplikacji + serwer poczty + dwa mendle innych ważnych serwerów; itp.).
Włożoną w projekt pracą (dyskusja innych możliwych rozwiązań odrzucanych na kolejnych etapach pracy; opis problemów z biblioteką pobraną z internetu, która wg dokumentacji miała działać, a na skutek jej błędów uruchomienie systemu zajęło miesiąc dodatkowej pracy; problemów z zamawiającym, którego poszczególni przedstawiciele uparli się składać sprzeczne między sobą wymagania; opis organizacji pracy zespołu, w którym wszyscy członkowie mieszkają każdy w innym mieście poza Warszawą, studiują na różnych kierunkach i dotąd się nie znali, jednocześnie pracują i to każdy w innych godzinach, a na koniec dwójka z nich się pobrała, ma trojaczki, właśnie wzięła urlop dziekański i chwilowo podróżuje tratwą po Pacyfiku; itp.).

Zwykle warto dodać jakiś kluczowy przypadek użycia z Państwa dokumentacji. W zależności od projektu mogą być bardzo pożądane zrzuty ekranów kluczowych części projektu. Znów w zależności od projektu mogą być potrzebne fragmenty kodu (do kilkunastu wierszy bezpośrednio w kodzie, do 2 stron jako załączniki do treści dokumentu).

\chapter{Organizacja pracy}

Pierwszym poważnym wyzwaniem, przed którym staneliśmy, była organizacja pracy zespołu. Każdy członek zespołu
pochodzi z innego miasta i uczęszcza na inne zajęcia, ponadto część członków pracuje. Znalezienie pory i dnia
tygodnia, w którym moglibyśmy się spotykać, stanowiło spore wyzwanie. W gospodarowaniu czasem i ustalaniu terminów
spotkań z klientem bardzo nam pomogło doodle. % Mądrze rozwinąć!
Komunikacja między członkami zespołu odbywała się głównie przez internet, przy pomocy facebooka %i slacka.
%Projekt prowadziliśmy w lekko zmodyfikowanej zwinnej metodyce opracowanej specjalnie na potrzeby naszego klienta.

\chapter{Wizja systemu}\label{r:wizja}

Celem naszego projektu było stworzenie prototypu internetowego frameworka do komunikacji obywatela z urzędami
podobnego do Platformy Usług Elektronicznych ZUS \cite{zuspue}, a następnie zaimplementowanie na niej jednego
wybranego przypadku użycia, np. usługi dokumentowania okresów zatrudnienia \cite{zusdoz}. Dzięki temu petent chcący
coś załatwić w urzędzie nie będzie musiał wychodzić z domu. Pewną inspiracją do stworzenia takiego systemu był
rządowy portal obywatel.gov.pl \cite{mcobywatel}.

Wyzwaniem, które należało uwzględnić w fazie projektowania, był szeroki zakres użytkowników systemu: od zwykłych
obywateli, poprzez urzędników, aż po przedsiębiorców. Każda z tych grup użytkowników miałaby zupełnie inne uprawnienia:
byłoby co najmniej niestosowne, gdyby przedsiębiorca wnioskowałby o urlop macierzyński dla prowadzonej przez siebie
firmy. Podobnie obywatel nie powinien mieć możliwości przyznania sobie emerytury lub renty (o ile nie jest urzędnikiem). Główne przypadki użycia systemu sprowadzałyby się do trzech wariantów: wypełniania wniosków, sprawdzania
odpowiedzi na wypełniony wniosek i rozpatrywania wniosków. Pobocznymi przypadkami byłyby: rezerwacja terminu wizyty w
urzędzie w przypadku nadzwyczaj zawiłych spraw, prezentacja różnych danych użytkownikowi (np. stanu ubezpieczenia,
wysokości przyznanej renty lub wymaganego ustawowo pouczenia) oraz wymiana korenspondencji z urzędnikiem. W obecnie
istniejącym systemie PUE jest jeszcze jeden przypadek użycia: czat z konsultantem. Nasza platforma powinna umożliwiać
stosunkowo prostą realizację niemal wszystkich spośród wymienionych wyżej przypadków użycia.

Kiedy użytkownik zaloguje się do naszego serwisu powinien zobaczyć pulpit, na którym wyświetlone są ,,kafelki''
odpowiadające poszczególnym usługom. Kliknięcie na wybrany kafelek powinno wyświetlić bardziej szczegółowy widok
odpowiadający podjętej akcji. Szczególnym życzeniem naszego klienta było, by architektura naszej aplikacji była
oparta na mikrousługach. Każda mikrousługa otrzymywałaby na wyłączność fragment pulpitu ograniczony do kafelka,
z możliwością przełączenia do trybu pełnoekranowego, gdzie przejmowałaby wtedy kontrolę nad większością wyświetlanego
obszaru. Aby to umożliwić, należało opracować ustandaryzowany i łatwo rozszerzalny interfejs do komunikacji między
cienkim klientem a mikrousługą. Preferowane było rozwiązanie, w którym komunikacja odbywałaby się bez pośrednictwa
serwera serwującego stronę internetową. Zamiast tego wykonywane byłyby asynchroniczne zapytania do mikrousługi (być
może poprzez warstwę integracji).

Postawione przed nami wymagania były głównie natury niefunkcjonalnej. Dołączanie kolejnej usługi do systemu
powinno być maksymalnie proste. Na tę prostotę składałby się ustandaryzowany interfejs do komunikacji pomiędzy
poszczególnymi usługami oraz modułowy i łatwo rozszerzalny interfejs użytkownika.
To pozwoli nam stosunkowo małym kosztem podłączać i odłączać kolejne usługi wraz z
rozwojem cyfrowej administracji. Usługi powinny tworzyć jeden ekosystem, z którego nie wychodziłby użytkownik. System
powinien być w dużej mierze odporny na awarie i zachowywać spójność oraz poprawność przechowywanych danych obywateli.
W szczególności powinny być spełnione normy ,,12 Factor App'' \cite{tfa}, w tym ta mówiąca, że awaria jednego serwera
lub usługi nie powinna wpływać na działanie pozostałych, niezależnych od niej udostępnianych usług.
Rozwój i utrzymanie platformy powinien być możliwy także dla słabiej wykształconych lub mniej doświadczonych
programistów, których nie pociągają uroki życia w dużym mieście. W ten sposób nasz projekt realizowałby plan
zrównoważonego rozwoju, zapobiegając zwijaniu się polski lokalnej, a z drugiej strony prowadziłby do wymiernych
oszczędności na wynagrodzeniach.

Innym istotnym aspektem naszego projektu było zerwanie z wizerunkiem ZUSu jako instytucji przestarzałej, niewydolnej
i pochodzącej ze słusznie minionego ustroju. Szata graficzna naszej platformy powinna być przyjemna dla oka, a układ
graficzny elementów logiczny, prosty do zrozumienia i konsekwentny. Użytkownik nie może być bombardowany zagadkowo
brzmiącymi komunikatami o ,,wchodzeniu na poziom bezpieczeństwa 1'' i ,,zamiarze korzystania z usług biznesowych''.
W żadnym przypadku praca z naszym systemem nie
powinna przypominać interakcji ze znudzonym i ślamazarnie wykonującym swoje obowiązki urzędnikiem, a to nakłada na
nas obowiązek rozwiązania problemu skalowalności aplikacji.

W związku z tym, że projektowaliśmy system dla administracji państwowej z którego będą korzystać miliony obywateli,
musieliśmy bardzo ostrożnie dobierać technologie, z których korzystaliśmy. Wybranie rozwiązania opartego na
niekorzystnej licencji mogło się w przyszłości srogo zemścić w postaci konieczności zapłacenia ogromnej opłaty
licencyjnej, wyłączenia usługi i przebudowania jej na nowo, udostępnienia części systemu na licencji open source, a
nawet konieczności nieodpłatnego przekazania przechowywanych danych obywateli licencjodawcy. Preferowane były
rozwiązania które albo były darmowe, albo do których nasz klient posiadał licencje (m. in. IBM DB2, komercyjna wersja PostgreSQL oraz cała gama produktów firmy Microsoft). W miarę możliwości
powinniśmy korzystać z nowoczesnych, przyszłościowych i rozwijanych technologii, tak, by odsunąć jak najdalej w
przyszłość konieczność przebudowy systemu z powodu zmieniających się trendów i narastającego długu technologicznego.

%Elementy, które powinny się znaleźć w dokumencie opisującym wizję to:
%Opis rozwiązania, Korzyści biznesowe, Wizja projektu i zakres, Analiza korzyści, Wymagania biznesowe, Wymagania użytkowników, Wymagania operacyjne, Wymagania systemowe, Wymagania bezpieczeństwa, Zakres projektu, Cele biznesowe, Cele techniczne, Kryteria operacyjne, Ograniczenia, Definicja profili użytkowników, Analizy użytkowania, Scenariusze wykorzystania

\chapter{Prototyp}\label{r:prototyp}

Przed przystąpieniem do opracowania projektu architektury wykonaliśmy przegląd obecnie dostępnych rozwiązań, które
mogłyby nam pomóc w realizacji wyznaczonych celów.

% TODO Komunikacja między usługami będzie odbywać się przez kolejki komunikatów beanstalkd lub apache kafka (powinna być niezawodna)
%Zadaniem usług bazodanowych jest zapewnienie rollbacku w przypadku jakiejkolwiek awarii (nawet podczas operacji na NoSQL) albo przepchnięcie operacji dalej.

\section{Problemy z współbieżnością mikrousług}

Nietrudno wyobrazić sobie sytuację, w której dwie współbieżnie działające mikrousługi
wprowadzają konfliktujące ze sobą zmiany. Pewną formą zabezpieczenia przed takimi sytuacjami
mogłoby być rozwiązywanie konfliktów przez mikrousługę pośredniczącą w dostępie do bazy danych.
Taka mikrousługa stanowiłaby wtedy coś w rodzaju sekcji krytycznej, uniemożliwiającej jednoczesne zapisy
i niespójne odczyty (niezależnie od atomowości operacji na bazie danych). 
Niestety, takie podejście może nie wystarczać, np. w przypadku dwóch niezależnie działających usług, które wpierw
odczytują jakąś informację z bazy danych, a następnie na podstawie uzyskanej informacji wybierają rodzaj
akcji do podjęcia i nadpisują część bazy danych.

Jest kilka możliwych rozwiązań tego problemu. Możemy je pogrupować ze względu na następujące cechy:
\begin{itemize}
	\item miejsce przechowywania blokad
	\item sposób zakładania blokad na usługi
	\item wielkość obiektów, które będą blokowane
\end{itemize}
Blokady mogą być przechowywane w dedykowanej, wydzielonej mikrousłudze lub w mikrousłudze, której dotyczą. W naszej opinii
pierwsze podejście jest o tyle lepsze, że pozwala na wykrywanie zakleszczeń. Wadą takiego rozwiązania jest
stosunkowo słabe zrównoleglanie i fakt, że taka mikrousługa stanowiłaby najsłabszy punkt systemu, którego awaria
skutkowałaby zablokowaniem wszystkich pozostałych usług. Blokady mogą być zakładane pojedyńczo, w miarę
postępu transakcji lub na jej samym początku (w takim przypadku mikrousługa musi dokładnie wiedzieć, z jakich
zasobów ma zamiar skorzystać). Wydaje nam się, że najsensowniejszym wariantem jest wykorzystanie rozwiązań
stosowanych w relacyjnych bazach danych, gdzie blokady są zakładane w miarę postępu transakcji, a w przypadku
wykrycia zakleszczenia zmiany są wycofywane, sama zaś usługa wywłaszczana. Przy kolejnej próbie takiej mikrousłudze
nadany zostaje większy priorytet, który zapewnia żywotność. W przypadku implementacji takiego podejścia należy
pamiętać o zapewnieniu mechanizmów wywłaszczania mikrousług, księgowania zmian, śledzenia transakcji, wykrywania
zakleszczeń, nadawania priorytetów oraz o możliwości zakładania możliwie małych blokad na pojedyńcze rekordy.
Niestety, z uwagi na ograniczone zasoby nie byliśmy w stanie zaimplementować mechanizmu synchronizacji w
przedstawiony wyżej sposób. Postanowiliśmy ograniczyć się do muteksów zakładanych na początku transakcji.

Do ustalenia pozostała tylko wielkość blokowanych przez muteks danych. Ze względów wydajnościowych blokowanie
całych mikrousług zapewniających dostęp do danych nie było możliwe. Z uwagi na opóźnienia w przesyłaniu informacji
przez sieć prowadziłoby to z jednej strony do marnowania mocy obliczeniowej serwera bazy danych, a z drugiej strony 
znacząco ograniczałoby ilość jednoczesnych operacji. Z kolei zakładanie blokad na konkretne wiersze w poszczególnych
mikrousługach jest nierealizowalne, gdyż w chwili zakładania muteksu usługa może nie wiedzieć, jakie konkretnie
wiersze zmodyfikuje. Postanowiliśmy znaleźć złoty środek i zakładać blokady na właściciela danych. Wynika to z
faktu, że w typowej urzędniczej praktyce wykonywane operacje dotyczą co najwyżej kilku osób.

Uzbrojeni w powyższe informacje wytypowaliśmy dwie usługi mogące działać jako zarządca rozproszonego muteksa:
redisson \cite{redisson} i ZooKeeper \cite{zookeeper}. Redisson jest rozwiązaniem implementującym algorytm Redlock
\cite{redislock}. Jego najważniejszą cechą jest odporność na awarie usług poprzez automatyczne zwalnianie blokady
po upływie określonego czasu. W internecie ukazała się bardzo interesująca polemika do przytoczonego algorytmu \cite{redisbad}.
Głównym zarzutem czynionym wobec algorytmu Redlock jest brak mechanizmu, który zapobiegałby następującej sytuacji:
mikrousługa A zakłada blokadę na zasób Z. Następnie zaczyna operację nadpisywania danych. W trakcie operacji
działanie mikrousługi z losowego powodu zostaje zawieszone (np. wystąpiło znaczne opóźnienie w połączeniu sieciowym
lub włączył się odśmiecacz pamięci). W tym czasie termin ważności blokady mija, zostaje ona zdjęta, a do akcji
wkracza mikrousługa B, która zakłada swoją blokadę, nadpisuje dane utworzone przez usługę A i kończy swoje
działanie. Na koniec usługa A zostaje wybudzona i kontynuuje swoje działanie, prowadząc do rozspójnienia danych.
Według autora polemiki rozwiązaniem tego problemu jest skorzystanie z mechanizmu współdzielonej blokady
zaimplementowanej w frameworku Apache Curator \cite{curatorlock} i korzystającej pod spodem z Apache ZooKeepera.
Jest to bezpieczniejsze rozwiązanie które nie pozwala na wygaśnięcie blokady z powodu upływającego
czasu, a w przypadku awarii mikrousługi i utraty połączenia z nią
automatycznie zdejmuje blokadę. Ponadto, jest to stosunkowo nowoczesny projekt wykorzystywany i rozwijany przez
duże firmy takie jak Netflix, co daje pewne nadzieje dotyczące stabilności i dojrzałości tego projektu.

Jest jeszcze jeden problem, na który użytkownicy naszej platformy mogą się natknąć. Mianowicie, nasza platforma
może integrować poprzez różne adaptery już istniejące usługi, które zupełnie nie są świadome istnienia
zaproponowanego mechanizmu blokad, więc nie są odporne na błędy wynikające z współbieżności.
Projektanci mikrousług korzystających z naszej platformy muszą być świadomi wszystkiego, co wyżej napisano.
Aby maksymalnie ułatwić im pracę uwzględniliśmy wyniki powyższych rozważań  przy projektowaniu API, jednak nie
jesteśmy w stanie rozwiązać wszystkich pojawiających się problemów.

\section{Zapewnianie odporności systemu na awarie}

Hystrix - jeszcze to sprawdzimy, strażnik na lockach %TODO

\section{Zapewnienie transakcyjności}

Jednym z wymagań pozafunkcjonalnych było zapewnienie skalowalności serwisu i mikrousług w sposób zachowujący transakcyjność.
Dołożenie lub utrata serwera nie powinna wpływać na poprawność transakcji i nie powinna w żadnym przypadku
prowadzić do utraty lub rozspójnienia danych. Typowym rozwiązaniem stosowanym w takim przypadku jest prowadzenie
komunikacji między klientem a serwerem w sposób bezstanowy.

Powstaje tutaj pytanie, czy w przypadku naszego serwisu jest to możliwe? Dopuszczalny jest scenariusz, w którym
mikrousługa pyta użytkownika o jakąś informację (np. stan cywilny), a następnie w zależności od udzielonej odpowiedzi
prosi o dodatkowe informacje, np. o dane małżonka. Rozwiązaniem tego problemu jest przeniesienie stanowości
transakcji z serwera do klienta. Wszystkie informacje dotyczące transakcji będą trzymane po stronie klienta, a
operacje, które mogą zaburzać integralność danych będą wykonywane w jednym momencie i w całości, bez rozbijania
na wiele części. Dane przechowywane w kliencie przez poszczególne mikrousługi będą odseparowane między sobą, tak aby
zapobiec konfliktom. W uzasadnionych przypadkach możliwe byłoby przechowywanie części danych (takich jak duże pliki)
po stronie serwera, oraz trzymanie w kliencie ich identyfikatora.

\section{Przegląd technologii do tworzenia frontendu}
Django, PHP, Spring i inne serwerowe podejścia są be. Zastanawiamy się nad dojo (najlepszą antyrekomendacją jest obecnie istniejący system PUE) vs angular 2 vs react (odpada, słaba licencja).

\section{Szyny danych a kolejki komunikatów}

W naszej architekturze mikrousług potrzebowaliśmy jakiejś metody komunikacji pomiędzy poszczególnymi mikrousługami.
Na początku nasza uwaga została przykuta przez szyny danych jako standardowe rozwiązanie korporacyjne wykorzystywane
przy integracji usług. Nasz klient jest w posiadaniu licencji na szynę danych WebMethods i to ją jako pierwszą
rozpatrywaliśmy. Niestety, dostępna publicznie internetowa dokumentacja tego rozwiązania ograniczała się do kilku
broszurek reklamowych i luźnych sloganów. Z czystej ostrożności zrezygnowaliśmy z tego oprogramowania, gdyż nie
mieliśmy absolutnie żadnej gwarancji, że wyczytane hasła reklamowe mają jakiekolwiek pokrycie w rzeczywistości.
Do kolejnej grupy sprawdzonych szyn danych należały rozwiązania takie jak: WSO2, Talend, Mule. Możliwości, które
oferowały wyglądały na obiecujące, ale zupełnie niepasujące do specyfiki naszego projektu. Jednym z celów naszej
platformy było opracowanie interfejsu, który pozwalałby na możliwie łatwe, automatyczne wpinanie i wypinanie
mikrousług. Nijak do tak postawionego celu miała się konieczność konfigurowania szyny danych przez panel wystawiony w sieci
WWW lub wręcz przy pomocy specjalnego środowiska programistycznego takiego jak Eclipse, z obowiązkową fazą kompilacji
i wgrywania na serwer. 

Rozwiązaniem wartym wspomnienia jest Zato, dość osobliwa szyna danych rozwijana przez osobę o polsko brzmiącym nazwisku. Jej głównymi cechami są skalowalność, możliwość rekonfiguracji w locie oraz bardzo dobra integracja z językiem python, co miało dla nas niebagatelne znaczenie na etapie wczesnych analiz. W zasadzie cała logika realizowana przez tę szynę danych mogła być zapisana w postaci skryptu pythona, co otwierało nas na zupełnie nowe możliwości integracji mikrousług. Rozważaliśmy scenariusz, w którym szyna danych odpowiadałaby za wykrywanie działających mikrousług, trzymanie ich spisu i metadanych z nimi powiązanych oraz rozgłaszanie tegoż spisu do warstwy prezentacji i innych mikrousług. Zrezygnowaliśmy z tego podejścia jako naruszającego zasadę separacji odpowiedzialności oraz wskutek zmian projektowych - rezygnacji z frameworka django, pyramid i podobnych na rzecz Angulara. Jak się potem okazało, istnieje już rozwiązanie które realizuje wyżej wymienione scenariusze - Apache Zookeeper.

Niepowodzenia przy poszukiwaniu odpowiadającej nam szyny danych skierowały nas w kierunku innych rozwiązań, takich jak
kolejki komunikatów. Głównym wymaganiem jakie postawiliśmy była bardzo duża odporność na różnego rodzaju błędy i
awarie. W idealnym modelu każda wiadomość w kolejce powinna mieć trzy stany: do przetworzenia, w trakcie przetwarzania, wykonany. Celem takiego modelu jest, by w przypadku awarii jednego serwera usługi jego zadanie było transparentnie przekazane serwerowi zastępczemu, bez przerywania operacji. Udało nam się znaleźć tylko jedną kolejkę spełniającą to wymaganie - Beanstalkd.

Innym ciekawym sposobem osiągnięcia niezawodności może być kolejka ukryta wewnątrz mikrousługi, która w razie awarii jednego serwera pozwalałaby na odczytanie zadania przez inny serwer i dokończenie go. Niestety wtedy mogą mieć miejsce problemy z atomowością operacji. Przykładowo, w sytuacji gdy zadanie w kolejce zostało oznaczone jako
wykonane, ale usługa wywołująca nie otrzymała jeszcze odpowiedzi nastąpi awaria wywoływanej mikrousługi, może dojść do
duplikacji wykonanej operacji lub rozspójnienia danych.

Jeszcze innym, ciekawym podejściem byłoby zastosowanie usługi udostępniającej niezawodny dostęp do czegoś w rodzaju dziennika. Wtedy moglibyśmy stosunkowo małym kosztem zaimplementować mechanizmy stosujące transakcyjność rodem z relacyjnych baz danych. Przykładami takich usług są DistributedLog i Kafka %TODO

\section{Usługi monitorowania stanu mikrousług}
Apache zookeeper + curator do loadbalancingu vs Netflix eureka (nie)

\section{Przegląd baz danych}

W naszym projekcie rodzaj użytej bazy danych nie miał większego znaczenia, gdyż dostęp do niej odbywa się poprzez
wyspecjalizowaną usługę zapewniającą dostęp do danych lub w ramach jednej mikrousługi, gdzie służy jako tymczasowe
składowisko informacji potrzebnych przy wykonywaniu operacji. W takim modelu rodzaj użytej bazy danych jest
transparentny dla usługi wywołującej.
Wymaganiami postawionymi przed użytą bazą danych były:
\begin{itemize}
\item Możliwość zapewnienia wysokiej niezawodności i odporności na utratę integralności danych.
\item Skalowalność
\item Elastyczny model danych pasujący do specyfiki informacji przetwarzanych przez naszego klienta.
\end{itemize}
W naszym projekcie użyliśmy bazy PostgreSQL, która jest rozwiązaniem spełniającym powyższe wymagania i znanym przez naszego klienta. Skalowalność jest zapewniona przez rozszerzenie pg\_shard które pozwala na sharding danych pomiędzy różnymi serwerami. Jest to dość unikalne rozwiązanie w świecie otwartych relacyjnych baz danych.

Spośród baz danych typu NoSQL szczególnie interesujące było Mongo DB. Zastosowany model danych wygląda na spełnienie
marzeń typowego urzędnika, gdyż wszystkie informacje przechowywane w tej bazie są zorganizowane w dokumenty,
które mogą być zagnieżdżone w sobie. W obrębie jednego dokumenty gwarantowane są atomowe odczyty i zapisy, które
działają jak transakcje.
% TODO
Sensowne jest też CouchDB. Redis jest zbyt prymitywny, a jego obsługa transakcji zbyt ograniczona, chociaż
może się przydać przy synchronizacji \cite{redislock}. Niezawodne: cassandra, hbase?

\section{API udostępniane przez mikrousługi biznesowe i frontend}

\chapter{Wkład poszczególnych członków zespołu w projekt}\label{r:wklad}
Opis tego co poszczególne osoby zrobiły w ramach projektu. To bardzo ważne, proszę zapisać jako osobny rozdział (czyli np. nie podrozdział).

\appendix
\chapter{Spis zawartości dołączonej płyty CD}\label{r:spis}
Dokładny spis zawartości towarzyszącej płytki (p. dalej). To bardzo ważne, proszę zapisać jako osobny rozdział (czyli np. nie podrozdział). Płytka CD/DVD/Blu-ray/...

Zawiera:\\
Pełną dokumentacją projektu w łatwo dającym się odczytać formacie (najlepiej pdf + źródło).
Program (w postaci źródłowej i potencjalnie umożliwiającej uruchomienie, to może oznaczać np. dostarczenie stosownych plików makefile, pomocniczych plików z danymi, opisu instalacji itp.).
Wszelkie inne dokumenty powstałe podczas zajęć (np. teksty prezentacji, teksty pracy z poprzedniego dużego punktu, itp.).

Płyta jest częścią pracy - trzeba tyle płyt co drukowanych egzemplarzy pracy. Płytkę trzeba przymocować do pracy, tak by a) nie wypadała b) dało się ją wyjąć i odczytać w komputerze :).

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem[DOZ]{zusdoz} ZUS, \textit{Dokumentowanie okresów zatrudnienia oraz
	wynagrodzenia}, http://www.zus.pl/files/Dokumentowanie\_okres\%C3\%B3w\_zatrudnienia.pdf

\bibitem[TFA]{tfa} Autor nieznany, \textit{The Twelve-Factor App}, https://12factor.net/

\bibitem[SDM]{govsm} Autor nieznany, \textit{Government Service Design Manual},
https://www.gov.uk/service-manual/index.html

\bibitem[MSV]{microsvc} Chris Richardson, \textit{Microservice architecture patterns and best practices},
http://microservices.io/

\bibitem[MCO]{mcobywatel} Ministerstwo Cyfryzacji, \textit{Portal Rzeczypospolitej Polskiej - Opis projektu},
https://mc.gov.pl/projekty/portal-rzeczypospolitej-polskiej/opis-projektu

\bibitem[PUE]{zuspue} ZUS, \textit{Platforma Usług Elektronicznych},
http://pue.zus.pl/

\bibitem[RDL]{redislock} Redis, \textit{Distributed locks with Redis},
https://redis.io/topics/distlock

\bibitem[RDS]{redisson} \textit{Redisson},
http://redisson.org/

\bibitem[AZK]{zookeeper} Apache, \textit{Apache ZooKeeper},
https://zookeeper.apache.org/

\bibitem[HTL]{redisbad} Martin Kleppmann, \textit{How to do distributed locking},
http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

\bibitem[CLK]{curatorlock} Apache, \textit{Apache Curator - Shared Lock},
http://curator.apache.org/curator-recipes/shared-lock.html

\end{thebibliography}

\end{document}
