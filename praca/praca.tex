\documentclass[licencjacka]{pracamgr}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

% Dane magistranta:

\author{Autorzy}

\nralbumu{Albumy}

\title{Framework oparty o wzorzec mikrousług na przykładzie portalu dla ZUS}

\tytulang{Project}

\kierunek{Informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{mgra Michała Możdżonka}

% miesiąc i~rok:
\date{Maj 2017}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.127. Ubezpieczenia społeczne}

% Słowa kluczowe:
\keywords{mikrousługi, SOA, trudne sprawy}

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  Potem dopiszemy.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

%\chapter{Organizacja pracy}

%Pierwszym poważnym wyzwaniem, przed którym staneliśmy, była organizacja pracy zespołu. Każdy członek zespołu
%pochodzi z innego miasta i uczęszcza na inne zajęcia, ponadto część członków pracuje. Znalezienie pory i dnia
%tygodnia, w którym moglibyśmy się spotykać, stanowiło spore wyzwanie. W gospodarowaniu czasem i ustalaniu terminów
%spotkań z klientem bardzo nam pomogło doodle. % Mądrze rozwinąć!
%Komunikacja między członkami zespołu odbywała się głównie przez internet, przy pomocy facebooka %i slacka.
%Projekt prowadziliśmy w lekko zmodyfikowanej zwinnej metodyce opracowanej specjalnie na potrzeby naszego klienta.

\chapter{Wprowadzenie}\label{r:wstep}

\section{Motywacja}

Celem naszego projektu było stworzenie prototypu internetowego frameworka do komunikacji obywatela z urzędami
podobnego do Platformy Usług Elektronicznych ZUS \cite{zuspue}, a następnie zaimplementowanie na niej kilku wybranych przypadków użycia. Dzięki temu petent chcący
coś załatwić w urzędzie nie będzie musiał wychodzić z domu. Pewną inspiracją do stworzenia takiego systemu był
rządowy portal obywatel.gov.pl \cite{mcobywatel}.

Wyzwaniem, które należało uwzględnić w fazie projektowania, był szeroki zakres użytkowników systemu: od zwykłych
obywateli, poprzez urzędników, aż po przedsiębiorców. Każda z tych grup użytkowników miałaby zupełnie inne uprawnienia:
byłoby co najmniej niestosowne, gdyby przedsiębiorca wnioskowałby o urlop macierzyński dla prowadzonej przez siebie
firmy. Podobnie obywatel nie powinien mieć możliwości przyznania sobie emerytury lub renty (o ile nie jest urzędnikiem). Główne przypadki użycia systemu sprowadzałyby się do trzech wariantów: wypełniania wniosków, sprawdzania
odpowiedzi na wypełniony wniosek i rozpatrywania wniosków. Pobocznymi przypadkami byłyby: rezerwacja terminu wizyty w
urzędzie w przypadku nadzwyczaj zawiłych spraw, prezentacja różnych danych użytkownikowi (np. stanu ubezpieczenia,
wysokości przyznanej renty lub wymaganego ustawowo pouczenia) oraz wymiana korenspondencji z urzędnikiem. W obecnie
istniejącym systemie PUE jest jeszcze jeden przypadek użycia: czat z konsultantem. Nasza platforma powinna umożliwiać
stosunkowo prostą realizację niemal wszystkich spośród wymienionych wyżej przypadków użycia.

Kiedy użytkownik zaloguje się do naszego serwisu powinien zobaczyć pulpit, na którym wyświetlone są ,,kafelki''
odpowiadające poszczególnym usługom. Kliknięcie na wybrany kafelek powinno wyświetlić bardziej szczegółowy widok
odpowiadający podjętej akcji. Szczególnym życzeniem naszego klienta było, by architektura naszej aplikacji była
oparta na mikrousługach. Każda mikrousługa otrzymywałaby na wyłączność fragment pulpitu ograniczony do kafelka,
z możliwością przełączenia do trybu pełnoekranowego, gdzie przejmowałaby wtedy kontrolę nad większością wyświetlanego
obszaru. Aby to umożliwić, należało opracować ustandaryzowany i łatwo rozszerzalny interfejs do komunikacji między
cienkim klientem a mikrousługą. Preferowane było rozwiązanie, w którym komunikacja odbywałaby się bez pośrednictwa
serwera serwującego stronę internetową. Zamiast tego wykonywane byłyby asynchroniczne zapytania do mikrousługi (być
może poprzez warstwę integracji).

Postawione przed nami wymagania były głównie natury niefunkcjonalnej. Dołączanie kolejnej usługi do systemu
powinno być maksymalnie proste. Na tę prostotę składałby się ustandaryzowany interfejs do komunikacji pomiędzy
poszczególnymi usługami oraz modułowy i łatwo rozszerzalny interfejs użytkownika.
To pozwoli nam stosunkowo małym kosztem podłączać i odłączać kolejne usługi wraz z
rozwojem cyfrowej administracji. Usługi powinny tworzyć jeden ekosystem, z którego nie wychodziłby użytkownik. System
powinien być w dużej mierze odporny na awarie i zachowywać spójność oraz poprawność przechowywanych danych obywateli.
W szczególności powinny być spełnione normy ,,12 Factor App'' \cite{tfa}, w tym ta mówiąca, że awaria jednego serwera
lub usługi nie powinna wpływać na działanie pozostałych, niezależnych od niej udostępnianych usług.
Rozwój i utrzymanie platformy powinien być możliwy także dla słabiej wykształconych lub mniej doświadczonych
programistów, których nie pociągają uroki życia w dużym mieście. W ten sposób nasz projekt realizowałby plan
zrównoważonego rozwoju, zapobiegając zwijaniu się polski lokalnej, a z drugiej strony prowadziłby do wymiernych
oszczędności na wynagrodzeniach.

\section{Zleceniodawca - ZUS}

Naszym zleceniodawcą był Zakład Ubezpieczeń Społecznych. Według ,,Rocznika
Statystycznego Ubezpieczeń Społecznych'' \cite{rocznik} w 2011 roku w ZUS było ubezpieczonych
14 milionów obywateli. Dochód Zakładu wyniósł w owym roku 155 796 milionów
złotych. Do obsługi takiej ilości petentów i zarządzania taką kwotą pieniędzy
było zatrudnionych przeciętnie 44 766 urzędników.

W związku z tym, że projektowaliśmy system dla administracji państwowej z
którego będą korzystać miliony obywateli, musieliśmy bardzo ostrożnie dobierać
technologie, z których korzystaliśmy. Wybranie rozwiązania opartego na
niekorzystnej licencji mogło się w przyszłości srogo zemścić w postaci
konieczności zapłacenia ogromnej opłaty licencyjnej, wyłączenia usługi i
przebudowania jej na nowo, udostępnienia części systemu na licencji open source,
a nawet konieczności nieodpłatnego przekazania przechowywanych danych obywateli
licencjodawcy. Preferowane były rozwiązania które albo były darmowe, albo do
których nasz klient posiadał licencje (m. in. IBM DB2, komercyjna wersja
PostgreSQL oraz cała gama produktów firmy Microsoft). W miarę możliwości
powinniśmy korzystać z nowoczesnych, przyszłościowych i rozwijanych technologii,
tak, by odsunąć jak najdalej w przyszłość konieczność przebudowy systemu z
powodu zmieniających się trendów i narastającego długu technologicznego.

Innym istotnym aspektem naszego projektu było zerwanie z wizerunkiem ZUSu jako
instytucji przestarzałej, niewydolnej i pochodzącej ze słusznie minionego
ustroju. Szata graficzna naszej platformy powinna być przyjemna dla oka, a układ
graficzny elementów logiczny, prosty do zrozumienia i konsekwentny. Użytkownik
nie może być bombardowany zagadkowo brzmiącymi komunikatami o ,,wchodzeniu na
poziom bezpieczeństwa 1'' i ,,zamiarze korzystania z usług biznesowych''. W
żadnym przypadku praca z naszym systemem nie powinna przypominać interakcji
ze znudzonym i ślamazarnie wykonującym swoje obowiązki urzędnikiem, a to
nakłada na nas obowiązek rozwiązania problemu skalowalności aplikacji.

\section{Produkt końcowy}
TODO % TODO

\chapter{Wymagania}

Głównym wymaganiem postawionym przed naszym frameworkiem było umożliwienie reimplementacji
Platformy Usług Elektronicznych ZUS (widocznej na poniższym obrazku) oraz stworzenie
przykładowego portalu ilustrującego jego możliwości.\\
\includegraphics[width=\textwidth]{obrazki/pue2.jpg}
Naszemu zespołowi pozostawiono bardzo duży stopień swobody przy projektowaniu i
implementacji portalu. Główny nacisk położono na innowacyjność stworzonego rozwiązania.
Niezależnie od tego, w trakcie naszych rozmów z klientem zostały wyłonione przedstawione
niżej wymagania.

\section{Wymagania funkcjonalne}

TODO - FE i mikrousługi % TODO

\section{Wymagania niefunkcjonalne}

Bardzo wiele uwagi poświęciliśmy wymaganiom niefunkcjonalnym. Nasz Klient bardzo
wyraźnie życzył sobie, by były spełnione normy ,,12 Factor App'' \cite{tfa}.
W szczególności, nasz serwis powinien cechować się wysokim współczynnikiem
niezawodnośći i odporności na losowe awarie. Ma to szczególne duże znaczenie
podczas komunikacji na linii obywatel -- państwo, gdzie jakiekolwiek rozbieżności
mogą być opłakane w skutkach. W miarę postępu cyfryzacji państwa liczba użytkowników
naszego serwisu będzie zbliżać się do 14-tu milionów osób. Należy zapewnić
skalowalność tworzonej aplikacji w sposób pozwalający na ich obsłużenie.

Platforma powinna być prosta w użyciu nawet dla relatywnie nisko wykwalifikowanych
programistów i utrudniać im popełnienie przynajmniej części błędów. Przykład
problemu występującego w obecnej wersji PUE jest widoczny na poniższym obrazku.
Ze względu na niewłaściwą architekturę systemu możliwe jest wyświetlenie
użytkownikowi sprzecznych komunikatów dotyczących stanu zalogowania. Nasz framework
nie powinien pozwalać na powstanie takiej sytuacji.\\
\includegraphics[width=\textwidth]{obrazki/logowaniezle.jpg}

Nasz serwis powinien cechować się spójnym i jednolitym wyglądem oraz wysoką
reużywalnością komponentów wykorzystywanych do tworzenia interfejsu użytkownika.
Interfejsy powininny być łatwo rozszerzalne bez łamania wstecznej kompatybilności
i konieczności modyfikacji już napisanych fragmentów aplikacji. W projekcie
należy uwzględnić dynamicznie zmieniające się środowisko w jakim przyjdzie działać
naszej aplikacji. Z powodu ciągle postępującej cyfryzacji państwa i związanych z
tym znacznych zmian w prawie możemy być pewni, że po oddaniu serwisu do użytku
ulegnie on znaczącym przekształceniom. Powinniśmy sprawić, by koszt owego przekształcenia
był jak najmniej dotkliwy dla naszego Klienta.

Wymaganiem bardzo podobnym do powyższego jest konieczność łatwej integracji z już
istniejącymi systemami informatycznymi. Przykładem takiego systemu w ZUS jest
,,Kompleksowy System Informatyczny''. Systemy które nie znajdują się pod zarządem ZUS
to między innymi ,,Profil Zaufany -- eGO'' oraz ,,System Rejestrów Państwowych''.
Nasz serwis powinien łatwo integrować się z wymienionym wyżej oprogramowaniem.
Należy uwzględnić fakt, że możliwość modyfikacji i dostosowania zewnętrznych
systemów do naszych potrzeb jest bardzo ograniczona.

System utworzony na bazie naszego frameworka powinien cechować się znacznym stopniem
automatyzacji. Dołączanie i odłączanie kolejnych serwerów powinno odbywać się w locie,
bez konieczności ręcznej rekonfiguracji. Ten postulat bardzo wydatnie łączy się z
wymaganiem skalowalności i niezawodności. Przeprowadzane zmiany w konfiguracji serwerów
nie powinny rzutować na niezawodność serwisu.

\chapter{Teoretyka}

\section{Problem}

Nasz produkt powinien w sposób maksymalnie prosty umożliwiać integrację systemów
informatycznych zakładu ubezpieczeń społecznych. Podstawowymi problemami jakie
należało uwzględnić na etapie projektowania systemu były:
\begin{itemize}
	\item Znaczny poziom skomplikowania istniejącego oprogramowania
	\item Duża ilość użytkowników naszego systemu
	\item Zapewnienie wysokiego poziomu odporności na awarie
\end{itemize}
Po przejrzeniu istniejących rozwiązań zaproponowaliśmy naszemu klientowi
architekturę opartą o mikrousługi.

\section{Mikrousługi}

Mikrousługi to stosunkowo nowy wzorzec architektoniczny będący rozwinięciem
architektury zorientowanej na usługi (ang. \textit{service-oriented architecture}).
Cechuje się ona rozbiciem poszczególnych składowych systemu na małe, luźno powiązane
usługi implementujące logikę biznesową. Znacząco ułatwia to ciągłą integrację (ang.
\textit{continuous integration}) oraz wdrożenie (ang. \textit{deployment}) dużych,
bardzo złożonych aplikacji. Ponadto pozwala to na stosunkowo dużą różnorodność
wykorzystanych technologii i stopniową ewolucję wykorzystywanego stosu technologicznego
\cite{microsvc}.

Zastosowanie mikrousług upraszcza proces skalowania całego systemu, co ma niebagatelne
znaczenie dla naszego klienta. W systemach o architekturze monolitycznej skalowanie
odbywa się na dwa sposoby: poprzez zastosowanie mocniejszej jednostki obliczeniowej
lub przez uruchomienie kolejnej instancji aplikacji na nowym serwerze. Pierwsze
podejście ma tę wadę, że stosunkowo szybko można osiągnąć górny pułap wydolności
dostępnego na rynku sprzętu. W drugim przypadku niezbędne jest zapewnienie mechanizmów
synchronizacji i replikacji danych, co w bardzo rozbudowanych systemach może okazać się
praktycznie niewykonalne. Architektura mikrousług oferuje mitygacje wymienionych problemów,
gdyż dzięki rozbiciu systemu na wiele małych usług możliwe jest
wystawienie każdej usługi na osobnym serwerze, zaś luźne ich powiązanie pomaga
zredukować nakłady na synchronizację pomiędzy poszczególnymi mikrousługami, dzięki
czemu kod staje się prostszy w utrzymaniu i modernizacji.

Zazwyczaj uznaje się, że każda mikrousługa powinna mieć własną bazę danych \cite{nginx},
do której pozostałe usługi nie mają bezpośredniego dostępu. Dzięki temu łatwiejsze
staje się wymuszenie luźnego powiązania usług, a ewolucja schematu bazy danych nie
wymusza zmian w całym kodzie aplikacji. Ponadto zespół pracujący nad daną mikrousługą
może w sposób nie wpływający na pozostałą część systemu wybrać tę bazę danych, która
najbardziej odpowiada rozwiązywanemu problemowi. Niestety to podejście ma swoje wady,
do których można zaliczyć konieczność utrzymywania spójności danych w niezależnych
od siebie systemach bazodanowych.

\section{Bezstanowość mikrousług}

Wśród dobrych praktyk konstruowania oprogramowania opartego o mikrousługi \cite{nginx}
jest ta, mówiąca o traktowaniu serwerów w sposób bezstanowy. Poszczególne serwery
należy traktować jak wymienialnych członków grupy. Wszystkie pełnią te same role i
wykonują tę samą pracę. Jeżeli jeden z nich ulegnie awarii, to obowiązki uszkodzonej
maszyny mogą przejąć pozostałe instacje. Podobnie dostawienie kolejnej instancji
nie powinno sprawiać większych trudności. Dzięki temu uzyskujemy teoretycznie
nieograniczoną skalowalność.

\section{Integracja mikrousług}
W naszej architekturze mikrousług potrzebowaliśmy jakiejś metody komunikacji
pomiędzy poszczególnymi mikrousługami. Poniżej wypisaliśmy najczęściej spotykane
rozwiązania tego problemu.

\subsection{Szyny danych}

Na początku nasza uwaga została przykuta przez szyny danych jako standardowe rozwiązanie korporacyjne wykorzystywane
przy integracji usług. Nasz klient jest w posiadaniu licencji na szynę danych WebMethods i to ją jako pierwszą
rozpatrywaliśmy. Niestety, dostępna publicznie internetowa dokumentacja tego rozwiązania ograniczała się do kilku
broszurek reklamowych i luźnych sloganów. Z czystej ostrożności zrezygnowaliśmy z tego oprogramowania, gdyż nie
mieliśmy absolutnie żadnej gwarancji, że wyczytane hasła reklamowe mają jakiekolwiek pokrycie w rzeczywistości.
Do kolejnej grupy sprawdzonych szyn danych należały rozwiązania takie jak: WSO2, Talend, Mule. Możliwości, które
oferowały wyglądały na obiecujące, ale zupełnie niepasujące do specyfiki naszego projektu. Jednym z celów naszej
platformy było opracowanie interfejsu, który pozwalałby na możliwie łatwe, automatyczne wpinanie i wypinanie
mikrousług. Nijak do tak postawionego celu miała się konieczność konfigurowania szyny danych przez panel wystawiony w sieci
WWW lub wręcz przy pomocy specjalnego środowiska programistycznego takiego jak Eclipse, z obowiązkową fazą kompilacji
i wgrywania na serwer. 

Rozwiązaniem wartym wspomnienia jest Zato, dość osobliwa szyna danych rozwijana przez osobę o polsko brzmiącym nazwisku. Jej głównymi cechami są skalowalność, możliwość rekonfiguracji w locie oraz bardzo dobra integracja z językiem python, co miało dla nas niebagatelne znaczenie na etapie wczesnych analiz. W zasadzie cała logika realizowana przez tę szynę danych mogła być zapisana w postaci skryptu pythona, co otwierało nas na zupełnie nowe możliwości integracji mikrousług. Rozważaliśmy scenariusz, w którym szyna danych odpowiadałaby za wykrywanie działających mikrousług, trzymanie ich spisu i metadanych z nimi powiązanych oraz rozgłaszanie tegoż spisu do warstwy prezentacji i innych mikrousług. Zrezygnowaliśmy z tego podejścia jako naruszającego zasadę separacji odpowiedzialności.

\subsection{Kolejki komunikatów}
Niepowodzenia przy poszukiwaniu odpowiadającej nam szyny danych skierowały nas w kierunku innych rozwiązań, takich jak
kolejki komunikatów. Głównym wymaganiem jakie postawiliśmy była bardzo duża odporność na różnego rodzaju błędy i
awarie. W idealnym modelu każda wiadomość w kolejce powinna mieć trzy stany: do przetworzenia, w trakcie przetwarzania, wykonany. Celem takiego modelu jest, by w przypadku awarii jednego serwera usługi jego zadanie było transparentnie przekazane serwerowi zastępczemu, bez przerywania operacji. Udało nam się znaleźć tylko jedną kolejkę spełniającą to wymaganie - Beanstalkd \cite{beanstalkd}.

Innym sposobem osiągnięcia niezawodności może być kolejka ukryta wewnątrz mikrousługi, która w razie awarii jednego serwera pozwalałaby na odczytanie zadania przez inny serwer i dokończenie go. Niestety wtedy mogą mieć miejsce problemy z atomowością operacji. Przykładowo, w sytuacji gdy zadanie w kolejce zostało oznaczone jako wykonane, ale usługa wywołująca nie otrzymała jeszcze odpowiedzi nastąpi awaria wywoływanej mikrousługi, może dojść do duplikacji wykonanej operacji lub rozspójnienia danych.

\subsection{Dzienniki}

Jeszcze innym, ciekawym podejściem byłoby zastosowanie usługi udostępniającej niezawodny dostęp do czegoś w rodzaju dziennika. Wtedy moglibyśmy stosunkowo małym kosztem zaimplementować mechanizmy stosujące transakcyjność rodem z relacyjnych baz danych. Przykładami takich usług są DistributedLog \cite{distibutedlog} i Kafka \cite{kafka}. Poszczególne mikrousługi monitorowałyby dziennik i z niego pobierały zmiany, a następnie reagowały na nie poprzez podjęcie jakiejś akcji. Można sobie wyobrazić dwa sposoby wykorzystania takiego dziennika. Pierwszy polegałby na tym, że wszystkie dokonane zmiany są atomowo publikowane w jednej dużej paczce, która musiałaby być potem rozpakowywana, a poszczególne zmiany wyłuskiwane. Drugim sposobem byłoby stworzenie dużej ilości dzienników na każdy rodzaj zdarzenia, a każda operacja byłaby wykonywana w małych krokach, w sposób potokowy.

\subsection{Rozwiązania oparte o BPMN}
W wymienionych wyżej modelach komunikacji serwery pośredniczące w wymianie
komunikatów nic nie wiedzą o procesach biznesowych, w których uczestniczą. 
Możliwa jest jednak realizacja zgoła przeciwnego podejścia, w którym działanie
wszystkich mikrousług jest koordynowane przez jedną centralną usługę.

Pozwalala ona na modelowanie procesów biznesowych przy pomocy graficznej
,,Notacji i Modelu Procesu Biznesowego'' (ang. \textit{Business Process Modeling
Notation}), a następnie wykonanie ich na specjalnie do tego celu skonstruowanym
silniku. Poszczególne mikrousługi stanowią w tym modelu ,,klocki'', z których
klient może sobie kontruować bardziej złożone procesy. Przykładami technologii,
które implementują wyżej wymienioną funkcjonalność są:
\begin{itemize}
	\item Camunda (oparty na Activiti)
	\item Bonita BPM
	\item jBPM
	\item Intalio BPMS
\end{itemize}

James Lewis i Martin Fowler w swojej publikacji \cite{fowlermicroservices}
stwierdzają, że powyższe podejście nie jest preferowane w środowisku mikrousług
gdyż stanowi złamanie zasady ,,sprytnych końcówek i bezmyślnych łączy'' (ang.
\textit{smart endpoints and dumb pipes}).

\section{Problemy z współbieżnością mikrousług}

Nietrudno wyobrazić sobie sytuację, w której dwie współbieżnie działające mikrousługi
wprowadzają konfliktujące ze sobą zmiany. Pewną formą zabezpieczenia przed takimi sytuacjami
mogłoby być rozwiązywanie konfliktów przez mikrousługę pośredniczącą w dostępie do bazy danych.
Taka mikrousługa stanowiłaby wtedy coś w rodzaju sekcji krytycznej, uniemożliwiającej jednoczesne zapisy
i niespójne odczyty (niezależnie od atomowości operacji na bazie danych). 
Niestety, takie podejście może nie wystarczać, np. w przypadku dwóch niezależnie działających usług, które wpierw
odczytują jakąś informację z bazy danych, a następnie na podstawie uzyskanej informacji wybierają rodzaj
akcji do podjęcia i nadpisują część bazy danych.

Jest kilka możliwych rozwiązań tego problemu. Możemy je pogrupować ze względu na następujące cechy:
\begin{itemize}
	\item miejsce przechowywania blokad
	\item sposób zakładania blokad na usługi
	\item wielkość obiektów, które będą blokowane
\end{itemize}
Blokady mogą być przechowywane w dedykowanej, wydzielonej mikrousłudze lub w mikrousłudze, której dotyczą. W naszej opinii
pierwsze podejście jest o tyle lepsze, że pozwala na wykrywanie zakleszczeń. Wadą takiego rozwiązania jest
stosunkowo słabe zrównoleglanie i fakt, że taka mikrousługa stanowiłaby najsłabszy punkt systemu, którego awaria
skutkowałaby zablokowaniem wszystkich pozostałych usług. Blokady mogą być zakładane pojedyńczo, w miarę
postępu transakcji lub na jej samym początku (w takim przypadku mikrousługa musi dokładnie wiedzieć, z jakich
zasobów ma zamiar skorzystać). Wydaje nam się, że najsensowniejszym wariantem jest wykorzystanie rozwiązań
stosowanych w relacyjnych bazach danych, gdzie blokady są zakładane w miarę postępu transakcji, a w przypadku
wykrycia zakleszczenia zmiany są wycofywane, sama zaś usługa wywłaszczana. Przy kolejnej próbie takiej mikrousłudze
nadany zostaje większy priorytet, który zapewnia żywotność. W przypadku implementacji takiego podejścia należy
pamiętać o zapewnieniu mechanizmów wywłaszczania mikrousług, księgowania zmian, śledzenia transakcji, wykrywania
zakleszczeń, nadawania priorytetów oraz o możliwości zakładania możliwie małych blokad na pojedyńcze rekordy.

Innym sposobem rozwiązania wyżej przedstawionego problemu jest zakładanie blokad na początku transakcji.
Ze względów wydajnościowych blokowanie przez muteks
całych mikrousług zapewniających dostęp do danych nie jest możliwe. Z uwagi na opóźnienia w przesyłaniu informacji
przez sieć prowadziłoby to z jednej strony do marnowania mocy obliczeniowej serwera bazy danych, a z drugiej strony
znacząco ograniczałoby ilość jednoczesnych operacji. Z kolei zakładanie blokad na konkretne wiersze w poszczególnych
mikrousługach jest nierealizowalne, gdyż w chwili zakładania muteksu usługa może nie wiedzieć, jakie konkretnie
wiersze zmodyfikuje. Uznaliśmy, że złotym środkiem jest zakładanie blokady na właściciela danych. Wynika to z
faktu, że w typowej urzędniczej praktyce wykonywane operacje dotyczą co najwyżej kilku osób.

Uzbrojeni w powyższe informacje wytypowaliśmy dwie usługi mogące działać jako zarządca rozproszonego muteksa:
redisson \cite{redisson} i ZooKeeper \cite{zookeeper}. Redisson jest rozwiązaniem implementującym algorytm Redlock
\cite{redislock}. Jego najważniejszą cechą jest odporność na awarie usług poprzez automatyczne zwalnianie blokady
po upływie określonego czasu. W internecie ukazała się bardzo interesująca polemika do przytoczonego algorytmu \cite{redisbad}.
Głównym zarzutem czynionym wobec algorytmu Redlock jest brak mechanizmu, który zapobiegałby następującej sytuacji:
mikrousługa A zakłada blokadę na zasób Z. Następnie zaczyna operację nadpisywania danych. W trakcie operacji
działanie mikrousługi z losowego powodu zostaje zawieszone (np. wystąpiło znaczne opóźnienie w połączeniu sieciowym
lub włączył się odśmiecacz pamięci). W tym czasie termin ważności blokady mija, zostaje ona zdjęta, a do akcji
wkracza mikrousługa B, która zakłada swoją blokadę, nadpisuje dane utworzone przez usługę A i kończy swoje
działanie. Na koniec usługa A zostaje wybudzona i kontynuuje swoje działanie, prowadząc do rozspójnienia danych.
Według autora polemiki rozwiązaniem tego problemu jest skorzystanie z mechanizmu współdzielonej blokady
zaimplementowanej w frameworku Apache Curator \cite{curatorlock} i korzystającej pod spodem z Apache ZooKeepera.
Jest to bezpieczniejsze rozwiązanie które nie pozwala na wygaśnięcie blokady z powodu upływającego
czasu, a w przypadku awarii mikrousługi i utraty połączenia z nią
automatycznie zdejmuje blokadę. Ponadto, jest to stosunkowo nowoczesny projekt wykorzystywany i rozwijany przez
duże firmy takie jak Netflix, co daje pewne nadzieje dotyczące stabilności i dojrzałości tego projektu.

\section{Rejestracja i wykrywanie mikrousług}

Zarządzanie infrastrukturą w systemie opartym o mikrousługi jest znacznie większym
wyzwaniem niż w systemie o architekturze monolitycznej. Dzieje się tak z powodu
dużej ilości różnych serwerów usług a także dlatego, że mikrousługi zachęcają do
stosowania wielu różnorodnych, nierzadko niekompatybilnych technologii. Ręczna
konfiguracja i administrowanie takim systemem pochłania znaczne zasoby, dlatego
postanowiliśmy ten proces zautomatyzować. Przedstawimy kilka powszechnie stosowanych
w przemyśle rozwiązań tego problemu.

Pierwszym z nich jest serwer Apache ZooKeeper \cite{zookeeper}. Dane na serwerze
ZooKeeper są trzymane w drzewiastej strukturze. Każdy węzeł może zawierać dowolny
ciąg bajtów ograniczony do rozmiaru ok. 1 Mb. Serwer pozwala na atomowe odczyty i
zapisy, ponadto może działać w klastrze. W takim przypadku gwarantowane jest zachowanie
sekwencji zapisów. Dostęp do danych jest chroniony przez mechanizm ACL.
Informacje o mikrousługach są przechowywane w węzłach drzewa i zazwyczaj składają
się na nie identyfikator serwera, adres internetowy, port usługi, informacja o
obsłudze SSL. Dzięki otwartości kodu źródłowego klient usługi dostępny jest na
większości wiodących platform.

Rozwiązaniem bardzo podobnym do ZooKeepera jest Consul. Zasadniczą różnicą
między tymi dwoma serwerami było zastosowanie w Consulu słownika typu
klucz-wartość oraz znacznie bardziej zaawansowane raportowanie stanu
mikrousługi, które obejmuje nie tylko informację o działaniu serwera usługi,
ale także okresowe sprawdzanie jego stanu przy pomocy specjalnie
zaprojektowanego RESTowego interfejsu. Ułatwia on integrację z platformami na
których nie jest dostępny klient Consula. Consul jest projektem komercyjnym.

Podobną, chociaż nieco okrojoną funkcjonalność w stosunku do Consula zapełniają
serwery etcd i Netflix Eureka. Ten pierwszy pozwalał na rozproszone składowanie
danych w słowniku typu klucz-wartość. Eureka z kolei zapewniała automatyczną
rejestrację, wykrywanie i odpytywanie mikrousług z zadaną częstotliwością oraz
monitorowanie ich stanu. Obydwa projekty mają otwarty kod źródłowy.

\section{Wnioski}

Nasz zespół zdecydował, że opracujemy rozwiązanie wykorzystujące mikrousługi.
Komunikacja z poszczególnymi serwerami powinna być bezstanowa. Konfiguracja
mikrousług będzie przechowywana w formie drzewa w centralnym serwerze o dużym
stopniu niezawodności.

Rozwiązania realizujące komunikację między mikrousługami uważamy za wysoce
niewystarczające i zbyt mało elastyczne. Postanowiliśmy stworzyć własną usługę
o funkcjonalnościach zbliżonych do szyny danych, która na dodatek pozwala na
zautomatyzowaną konfigurację bez przerywania swojej pracy.

Nasz framework nie będzie rozwiązywał problemu rozproszonej synchronizacji między
usługami. Wynika to z bardzo dużej różnorodności sposobów na jakie można to uczynić.
Nasza platforma może integrować poprzez różne adaptery już istniejące usługi,
które zupełnie nie są świadome istnienia zaproponowanego mechanizmu blokad,
więc możliwe byłyby niekompatybilności między rozwiązaniem zaproponowanym
przez nas a wymienionymi usługami. Przykładami problematycznych usług mogą być
,,System Rejestrów Państwowych'' oraz ,,Kompleksowy System Informatyczny'' do
których dokumentacji z oczywistych względów nie mamy dostępu, więc nie możemy
przewidzieć trudności jakie nasza platforma będzie narzucać naszym użytkownikom.
To programiści korzystający z naszego systemu będą musieli rozwiązać ten problem
w sposób, jaki uznają za optymalny.

\chapter{Wykorzystane technologie}

Nasz serwis wykorzystuje bardzo dużą ilość różnych technologii. Związane jest to
z charakterem naszego projektu, który polegał na integracji usług napisanych w
możliwie różnych technologiach.

\section{Języki programowania}

Do realizacji części frontendowej wykorzystaliśmy platformę Node.js. Jej użycie
było związane z biblioteką Angular 2. Rzeczą całkowicie naturalną okazał się
wybór języków JavaScript i TypeScript do implementacji tej części serwisu.

Do napisania części backendowej początkowo wykorzystywaliśmy język Java. Głównymi
argumentami przemawiającymi za tym wyborem był bogaty zbiór bibliotek wykorzystywanych
w aplikacjach korporacyjnych, wysoka wydajność maszyny wirtualnej Java oraz fakt, że
obecnie istniejące systemy prawdopodobnie wykorzystują ten język. W trakcie naszych
prac okazało się, że jest to zupełnie nietrafiony wybór. Narastające problemy
pojawiające się podczas współpracy z wybranymi bibliotekami oraz niezadowalające
tempo prac w połączeniu ze zbliżającymi się terminami skłoniły nas do przepisania
już napisanego oprogramowania na język Python.

W przypadku naszego projektu radykalna decyzja o zmianie wykorzystywanego ekosystemu
była o tyle prosta, że nasz serwis miał charakter prototypu ilustrującego pewne
idee i niewykorzystywanego w środowisku produkcyjnym. Bardzo szybko okazało się, że
była to trafiona decyzja pozwalająca na mitygacje problemów, które pojawiły się w
trakcie naszych prac.

\section{Angular 2}

Do tworzenia cześć wizualnej oraz logiki bezpośrednio z nią związanej, użyliśmy frameworka Angular 2. Jest to narzędzie stworzone przez Google, opierające się
na TypeScript - języku będącym nadzbiorem JavaScript. W stosunku do JavaScript główną funkcjonalnością TypeScript jest dodanie obiektowości, jednakże można stwierdzić,
że wszystko co związane z obiektowością w TypeScript to tylko lukier syntaktyczny, ponieważ kod TypeScript podczas kompilacji jest tłumaczony do czystego JavaScript. TypeScript implementuje większość
funkcjonalności, które język obiektowy powinien oferować - możliwe jest dziedziczenie, tworzenie interfesjów, konstruktory itp. Ciekawą opcją są dekoratory (szerzej opisane w dalszej części pracy), czyli
ozdobniki klas które pozwalają na zmianę ``zachowania'' klasy już w trakcie kompilacji.

\section{Bootstrap}

Za wygląd strony odpowiada HTML5, połączony z Bootstrapem. Bootstrap to zbiór gotowych komponentów wizualnych, pozwalający, bez zbędnego wnikania
w stronę ``artystyczną'', tworzyć strony estetyczne oraz wygodne w użyciu. Jako, że tematem naszej pracy nie jest projektowanie stron internetowych,
użyliśmy gotowej skórki sbAdmin2, w której wprowadziliśmy
liczne zmiany.

\section{Django}

TODO

\section{Express.js}

Do serwowania części frontendowej serwisu wykorzystujemy serwer Express.js.
Korzystanie z niego jest proste i stosunkowo przyjemne, znakomicie integruje się
on z platformą Node.js. W przeciwieństwie do Lite--servera z którego korzystaliśmy
wcześniej, Express.js jest dobrze udokumentowany i udostępnia bogate API, z którego
skorzystaliśmy przy integracji z backendem.

\section{gRPC}

Podczas projektowania mechanizmu komunikacji pomiędzy mikrousługami nasz Klient
zasugerował użycie WSDL. Nie zgodziliśmy się na to, gdyż użycie tak ciężkiego
protokołu jest sprzeczne z typowymi praktykami stosowanymi w architekturze
mikrousług \cite{mammatustech}. Jednocześnie nie chcieliśmy, by nasza aplikacja
była ograniczona tylko i wyłącznie do RESTowych protokołów. Ostatecznie
zaproponowaliśmy użycie gRPC, który łączy zalety obu wymienionych wcześniej
rozwiązań. Z jednej strony jest stosunkowo lekkim i wykorzystującym niewiele
zasobów protokołem sieciowym, a z drugiej strony pozwala na ścisłe zdefiniowanie
udostępnianych przez serwer usług w czytelnym dla ludzi formacie. Po napisaniu
odpowiednich definicji możliwa jest ich kompilacja do gotowego kodu źródłowego
włączanego bezpośrednio w pliki projektu. Dzięki temu minimalizowane jest ryzyko
popełnienia błędu przy pisaniu modułu do komunikacji z innymi usługami.

\section{Play Framework}

TODO

\section{SQLite}

W naszym projekcie rodzaj użytej bazy danych nie miał większego znaczenia, gdyż
dostęp do niej odbywa się poprzez wyspecjalizowaną usługę zapewniającą dostęp do
danych lub w ramach jednej mikrousługi, gdzie służy jako tymczasowe składowisko
informacji potrzebnych przy wykonywaniu operacji. W takim modelu rodzaj użytej
bazy danych jest transparentny dla usługi wywołującej. Z uwagi na prototypowy
charakter naszego projektu poprzestaliśmy na bazie SQLite, jako że znakomicie
integruje się ona z Django, ponadto zastąpienie jej PostgreSQLem jest
praktycznie bezkosztowe.

\section{ZooKeeper}

Jednym z elementów wizji naszego systemu był fakt, że poszczególne usługi
powinny możliwie prosto ,,wpinać się'' w system. Serwer mikrousługi w trakcie
uruchamiania dopisywałby do globalnej konfiguracji wpisy związane z prowadzoną
przez siebie działalnością, takie jak adresy pod którymi przyjmuje zapytania
albo pozycje w menu widocznym dla użytkownika, które prowadzą do poszczególnych
usług biznesowych. Doszliśmy do wniosku, że nasze oczekiwania można sprowadzić
do trzech wymagań:
\begin{itemize}
	\item przechowywania konfiguracji w drzewiastej strukturze
	\item automatycznego usuwania dokładnie określonych wpisów w przypadku
	utraty dowolnego serwera mikrousługi
	\item automatyczną replikację danych
\end{itemize}

Najbliższy naszym potrzebom był serwer Apache ZooKeeper \cite{zookeeper} w
połączeniu z biblioteką Apache Curator \cite{curator}. Dane na serwerze
ZooKeeper są trzymane w drzewiastej strukturze. Każdy węzeł może zawierać dowolny
ciąg bajtów ograniczony do rozmiaru ok. 1 Mb. Węzły są wersjonowane, a dostęp
do nich jest kontrolowany przez mechanizm ACL. Na każdym węźle można ustawić
obserwatora (ang. \textit{watch}), który w przypadku jakiejkolwiek modyfikacji
węzła powiadamia klienta o zmianie. Oprócz tego, każdy węzeł może mieć ustawione
dwie dodatkowe flagi. Pierwsza to \textit{ephemeral}, która oznacza, że węzeł ma
istnieć tylko do czasu zakończenia sesji klienta, który utworzył dany węzeł.
Ta własność jest szczególnie interesująca w kontekście automatycznego
wyrejestrowywania usługi która kończy swe działanie i nie ma możliwości
powiadomienia serwera o tym fakcie. Druga flaga to \textit{sequence}. Mówi ona,
że należy do nazwy tworzonego węzła dopisać rosnący numer. Ma to zastosowanie we
wszelkiego rodzaju kolejkach, algorytmach synchronizujących i przy wyborze
lidera \cite{curatorlock}.

\subsection{Curator}

Biblioteka Curator upraszcza wiele aspektów związanych
z wykorzystaniem ZooKeepera, między innymi rejestrację serwerów mikrousług,
zapewnia implementację najczęściej wykorzystywanych algorytmów synchronizujących
oraz łatwe buforowanie drzewa węzłów wraz z automatycznym pobieraniem zmian. W
trakcie prac nad integratorem okazało się, że oferowane możliwości znacznie przekraczają
nasze potrzeby.

\subsection{Kazoo}

Kazoo jest nieoficjalnym klientem ZooKeepera dla języka Python. W trakcie
implementacji naszej aplikacji doceniliśmy jego niezawodność i prostotę użycia.

\chapter{Realizacja}

\section{Architektura aplikacji}

\subsection{Frontend}

\subsection{Integrator}
Integrator - autodiscovery usług, możliwość spinania różnych interfejsów gRPC, WSDL. 
Z uwagi na to, że dane przechodzą przez niego w postaci nieszyfrowanej można
go podłączyć do IDSa wykrywającego anomalie w przesyłanych danych i w ten sposób
zapobiegać masowemu wyciekowi wrażliwych danych lub atakom hakerskim. Stanowi też
dodatkową linię obrony, którą musi sforsować potencjalny haker. Dzięki temu system jest
odporniejszy na błędy popełnione w serwerach mikrousług, a w przypadku wykrycia
jakiejś luki można ad-hoc wprowadzić łatkę bezpieczeństwa w serwerze pośredniczącym
zamiast łatać wszystkie podatne serwery mikrousług.

\subsection{Mikrousługi}
TODO

\section{Frontend}

\subsection{Tworzenie mockupów}
Tutaj opis wszystkich stworzonych podstron
\subsection{Stworzenie systemu komponentów}
Opis posczególnych komponentów, oraz całej idei architektury tego rozwiązania.
\subsection{System tworzenia automatycznej dokumentacji}
Opis dekoratorów.
\subsection{Edytor}
TODO
\subsection{Platforma developera}
Sposób dodawania mikrosusług, style guide.

\section{Serwer uwierzytelniania i autoryzacji}

\section{Integrator}

TODO - O integratorze (niedziałający SSL, ciągle się zawiesza), integrator 2.0

\section{Mikrousługi}

\subsection{Powiadomienia}

\subsection{Logger}

\chapter{Obserwator emerytalny}
Z uwagi na bardzo niepewny charakter naszego projektu i trudności związane z
formalnym rozliczeniem naszej pracy zdecydowaliśmy się wykonać niejako poza
głównym projektem serwis ,,Obserwator emerytalny''.

\chapter{Wkład poszczególnych członków zespołu w projekt}
TODO

\chapter{Podsumowanie}
TODO

\appendix
\chapter{Spis zawartości dołączonej płyty CD}
Dokładny spis zawartości towarzyszącej płytki (p. dalej). To bardzo ważne, proszę zapisać jako osobny rozdział (czyli np. nie podrozdział). Płytka CD/DVD/Blu-ray/...

Zawiera:\\
Pełną dokumentacją projektu w łatwo dającym się odczytać formacie (najlepiej pdf + źródło).
Program (w postaci źródłowej i potencjalnie umożliwiającej uruchomienie, to może oznaczać np. dostarczenie stosownych plików makefile, pomocniczych plików z danymi, opisu instalacji itp.).
Wszelkie inne dokumenty powstałe podczas zajęć (np. teksty prezentacji, teksty pracy z poprzedniego dużego punktu, itp.).

Płyta jest częścią pracy - trzeba tyle płyt co drukowanych egzemplarzy pracy. Płytkę trzeba przymocować do pracy, tak by a) nie wypadała b) dało się ją wyjąć i odczytać w komputerze :).

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem[TFA]{tfa} Autor nieznany, \textit{The Twelve-Factor App}, https://12factor.net/

\bibitem[SDM]{govsm} Autor nieznany, \textit{Government Service Design Manual},
https://www.gov.uk/service-manual/index.html

\bibitem[MSV]{microsvc} Chris Richardson, \textit{Microservice architecture patterns and best practices},
http://microservices.io/

\bibitem[MCO]{mcobywatel} Ministerstwo Cyfryzacji, \textit{Portal Rzeczypospolitej Polskiej - Opis projektu},
https://mc.gov.pl/projekty/portal-rzeczypospolitej-polskiej/opis-projektu

\bibitem[PUE]{zuspue} ZUS, \textit{Platforma Usług Elektronicznych},
http://pue.zus.pl/

\bibitem[RDL]{redislock} Redis, \textit{Distributed locks with Redis},
https://redis.io/topics/distlock

\bibitem[RDS]{redisson} \textit{Redisson},
http://redisson.org/

\bibitem[AZK]{zookeeper} Apache, \textit{Apache ZooKeeper},
https://zookeeper.apache.org/

\bibitem[ACU]{curator} Apache, \textit{Apache Curator},
http://curator.apache.org/

\bibitem[HTL]{redisbad} Martin Kleppmann, \textit{How to do distributed locking},
http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

\bibitem[CLK]{curatorlock} Apache, \textit{Apache Curator - Shared Lock},
http://curator.apache.org/curator-recipes/shared-lock.html

\bibitem[Fowler]{fowlermicroservices} James Lewis, Martin Fowler, \textit{Microservices},
https://martinfowler.com/articles/microservices.html

\bibitem[RSUS]{rocznik} ZUS, \textit{Rocznik Statystyczny Ubezpieczeń Społecznych},
http://www.zus.pl/baza-wiedzy/statystyka/rocznik-statystyczny-ubezpieczen-spolecznych

\bibitem[Beanstlkd]{beanstalkd} Keith Rarick, \textit{Beanstalkd},
http://kr.github.io//beanstalkd/

\bibitem[Kafka]{kafka} Apache, \textit{Kafka},
https://kafka.apache.org/

\bibitem[DL]{distibutedlog} Apache, \textit{DistributedLog},
http://distributedlog.incubator.apache.org/

\bibitem[Netflix]{nginx} Tony Mauro, \textit{Adopting Microservices at Netflix: Lessons for Architectural Design},
https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/

\bibitem[mammatustech]{mammatustech} Rick Hightower, \textit{Java Microservices Architecture},
http://www.mammatustech.com/java-microservices-architecture

\end{thebibliography}

\end{document}
