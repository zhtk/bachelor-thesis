\documentclass[licencjacka]{pracamgr}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

% Dane magistranta:

\author{Autorzy}

\nralbumu{Albumy}

\title{Framework oparty o wzorzec mikrousług na przykładzie portalu dla ZUS}

\tytulang{Project}

\kierunek{Informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{mgra Michała Możdżonka\\
  }

% miesiąc i~rok:
\date{Maj 2017}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.127. Ubezpieczenia społeczne}

% Słowa kluczowe:
\keywords{mikrousługi, SOA, trudne sprawy}

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  Potem dopiszemy.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

%\chapter{Organizacja pracy}

%Pierwszym poważnym wyzwaniem, przed którym staneliśmy, była organizacja pracy zespołu. Każdy członek zespołu
%pochodzi z innego miasta i uczęszcza na inne zajęcia, ponadto część członków pracuje. Znalezienie pory i dnia
%tygodnia, w którym moglibyśmy się spotykać, stanowiło spore wyzwanie. W gospodarowaniu czasem i ustalaniu terminów
%spotkań z klientem bardzo nam pomogło doodle. % Mądrze rozwinąć!
%Komunikacja między członkami zespołu odbywała się głównie przez internet, przy pomocy facebooka %i slacka.
%Projekt prowadziliśmy w lekko zmodyfikowanej zwinnej metodyce opracowanej specjalnie na potrzeby naszego klienta.

\chapter{Wprowadzenie}\label{r:wstep}

\section{Motywacja}

Celem naszego projektu było stworzenie prototypu internetowego frameworka do komunikacji obywatela z urzędami
podobnego do Platformy Usług Elektronicznych ZUS \cite{zuspue}, a następnie zaimplementowanie na niej kilku wybranych przypadków użycia. Dzięki temu petent chcący
coś załatwić w urzędzie nie będzie musiał wychodzić z domu. Pewną inspiracją do stworzenia takiego systemu był
rządowy portal obywatel.gov.pl \cite{mcobywatel}.

Wyzwaniem, które należało uwzględnić w fazie projektowania, był szeroki zakres użytkowników systemu: od zwykłych
obywateli, poprzez urzędników, aż po przedsiębiorców. Każda z tych grup użytkowników miałaby zupełnie inne uprawnienia:
byłoby co najmniej niestosowne, gdyby przedsiębiorca wnioskowałby o urlop macierzyński dla prowadzonej przez siebie
firmy. Podobnie obywatel nie powinien mieć możliwości przyznania sobie emerytury lub renty (o ile nie jest urzędnikiem). Główne przypadki użycia systemu sprowadzałyby się do trzech wariantów: wypełniania wniosków, sprawdzania
odpowiedzi na wypełniony wniosek i rozpatrywania wniosków. Pobocznymi przypadkami byłyby: rezerwacja terminu wizyty w
urzędzie w przypadku nadzwyczaj zawiłych spraw, prezentacja różnych danych użytkownikowi (np. stanu ubezpieczenia,
wysokości przyznanej renty lub wymaganego ustawowo pouczenia) oraz wymiana korenspondencji z urzędnikiem. W obecnie
istniejącym systemie PUE jest jeszcze jeden przypadek użycia: czat z konsultantem. Nasza platforma powinna umożliwiać
stosunkowo prostą realizację niemal wszystkich spośród wymienionych wyżej przypadków użycia.

Kiedy użytkownik zaloguje się do naszego serwisu powinien zobaczyć pulpit, na którym wyświetlone są ,,kafelki''
odpowiadające poszczególnym usługom. Kliknięcie na wybrany kafelek powinno wyświetlić bardziej szczegółowy widok
odpowiadający podjętej akcji. Szczególnym życzeniem naszego klienta było, by architektura naszej aplikacji była
oparta na mikrousługach. Każda mikrousługa otrzymywałaby na wyłączność fragment pulpitu ograniczony do kafelka,
z możliwością przełączenia do trybu pełnoekranowego, gdzie przejmowałaby wtedy kontrolę nad większością wyświetlanego
obszaru. Aby to umożliwić, należało opracować ustandaryzowany i łatwo rozszerzalny interfejs do komunikacji między
cienkim klientem a mikrousługą. Preferowane było rozwiązanie, w którym komunikacja odbywałaby się bez pośrednictwa
serwera serwującego stronę internetową. Zamiast tego wykonywane byłyby asynchroniczne zapytania do mikrousługi (być
może poprzez warstwę integracji).

Postawione przed nami wymagania były głównie natury niefunkcjonalnej. Dołączanie kolejnej usługi do systemu
powinno być maksymalnie proste. Na tę prostotę składałby się ustandaryzowany interfejs do komunikacji pomiędzy
poszczególnymi usługami oraz modułowy i łatwo rozszerzalny interfejs użytkownika.
To pozwoli nam stosunkowo małym kosztem podłączać i odłączać kolejne usługi wraz z
rozwojem cyfrowej administracji. Usługi powinny tworzyć jeden ekosystem, z którego nie wychodziłby użytkownik. System
powinien być w dużej mierze odporny na awarie i zachowywać spójność oraz poprawność przechowywanych danych obywateli.
W szczególności powinny być spełnione normy ,,12 Factor App'' \cite{tfa}, w tym ta mówiąca, że awaria jednego serwera
lub usługi nie powinna wpływać na działanie pozostałych, niezależnych od niej udostępnianych usług.
Rozwój i utrzymanie platformy powinien być możliwy także dla słabiej wykształconych lub mniej doświadczonych
programistów, których nie pociągają uroki życia w dużym mieście. W ten sposób nasz projekt realizowałby plan
zrównoważonego rozwoju, zapobiegając zwijaniu się polski lokalnej, a z drugiej strony prowadziłby do wymiernych
oszczędności na wynagrodzeniach.

\section{Zleceniodawca - ZUS}

Naszym zleceniodawcą był Zakład Ubezpieczeń Społecznych. Według ,,Rocznika
Statystycznego Ubezpieczeń Społecznych'' \cite{rocznik} w 2011 roku w ZUS było ubezpieczonych
14 milionów obywateli. Dochód Zakładu wyniósł w owym roku 155 796 milionów
złotych. Do obsługi takiej ilości petentów i zarządzania taką kwotą pieniędzy
było zatrudnionych przeciętnie 44 766 urzędników.

W związku z tym, że projektowaliśmy system dla administracji państwowej z
którego będą korzystać miliony obywateli, musieliśmy bardzo ostrożnie dobierać
technologie, z których korzystaliśmy. Wybranie rozwiązania opartego na
niekorzystnej licencji mogło się w przyszłości srogo zemścić w postaci
konieczności zapłacenia ogromnej opłaty licencyjnej, wyłączenia usługi i
przebudowania jej na nowo, udostępnienia części systemu na licencji open source,
a nawet konieczności nieodpłatnego przekazania przechowywanych danych obywateli
licencjodawcy. Preferowane były rozwiązania które albo były darmowe, albo do
których nasz klient posiadał licencje (m. in. IBM DB2, komercyjna wersja
PostgreSQL oraz cała gama produktów firmy Microsoft). W miarę możliwości
powinniśmy korzystać z nowoczesnych, przyszłościowych i rozwijanych technologii,
tak, by odsunąć jak najdalej w przyszłość konieczność przebudowy systemu z
powodu zmieniających się trendów i narastającego długu technologicznego.

Innym istotnym aspektem naszego projektu było zerwanie z wizerunkiem ZUSu jako
instytucji przestarzałej, niewydolnej i pochodzącej ze słusznie minionego
ustroju. Szata graficzna naszej platformy powinna być przyjemna dla oka, a układ
graficzny elementów logiczny, prosty do zrozumienia i konsekwentny. Użytkownik
nie może być bombardowany zagadkowo brzmiącymi komunikatami o ,,wchodzeniu na
poziom bezpieczeństwa 1'' i ,,zamiarze korzystania z usług biznesowych''. W
żadnym przypadku praca z naszym systemem nie powinna przypominać interakcji
ze znudzonym i ślamazarnie wykonującym swoje obowiązki urzędnikiem, a to
nakłada na nas obowiązek rozwiązania problemu skalowalności aplikacji.

\section{Produkt końcowy}
TODO

\chapter{Teoretyka}

\section{Mikrousługi}

Mikrousługi to stosunkowo nowy wzorzec architektoniczny będący rozwinięciem
architektury zorientowanej na usługi (ang. \textit{service-oriented architecture}).
Cechuje się ona rozbiciem poszczególnych składowych systemu na małe, luźno powiązane
usługi implementujące logikę biznesową. Znacząco ułatwia to ciągłą integrację (ang.
\textit{continuous integration}) oraz wdrożenie (ang. \textit{deployment}) dużych,
bardzo złożonych aplikacji. Ponadto pozwala to na stosunkowo dużą różnorodność
wykorzystanych technologii i stopniową ewolucję wykorzystywanego stosu technologicznego
\cite{microsvc}.

Zastosowanie mikrousług upraszcza proces skalowania całego systemu, co ma niebagatelne
znaczenie dla naszego klienta. W systemach o architekturze monolitycznej skalowanie
odbywa się na dwa sposoby: poprzez zastosowanie mocniejszej jednostki obliczeniowej
lub przez uruchomienie kolejnej instancji aplikacji na nowym serwerze. Pierwsze
podejście ma tę wadę, że stosunkowo szybko można osiągnąć górny pułap wydolności
dostępnego na rynku sprzętu. W drugim przypadku niezbędne jest zapewnienie mechanizmów
synchronizacji i replikacji danych, co w bardzo rozbudowanych systemach może okazać się
praktycznie niewykonalne. Architektura mikrousług oferuje mitygacje wymienionych problemów,
gdyż dzięki rozbiciu systemu na wiele małych usług możliwe jest
wystawienie każdej usługi na osobnym serwerze, zaś luźne ich powiązanie pomaga
zredukować nakłady na synchronizację pomiędzy poszczególnymi mikrousługami, dzięki
czemu kod staje się prostszy w utrzymaniu i modernizacji.

\section{Bezstanowość mikrousług}
TODO
https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/
prywatna baza danych

\section{Integracja mikrousług}
W naszej architekturze mikrousług potrzebowaliśmy jakiejś metody komunikacji pomiędzy poszczególnymi mikrousługami.

\subsection{Szyny danych}

Na początku nasza uwaga została przykuta przez szyny danych jako standardowe rozwiązanie korporacyjne wykorzystywane
przy integracji usług. Nasz klient jest w posiadaniu licencji na szynę danych WebMethods i to ją jako pierwszą
rozpatrywaliśmy. Niestety, dostępna publicznie internetowa dokumentacja tego rozwiązania ograniczała się do kilku
broszurek reklamowych i luźnych sloganów. Z czystej ostrożności zrezygnowaliśmy z tego oprogramowania, gdyż nie
mieliśmy absolutnie żadnej gwarancji, że wyczytane hasła reklamowe mają jakiekolwiek pokrycie w rzeczywistości.
Do kolejnej grupy sprawdzonych szyn danych należały rozwiązania takie jak: WSO2, Talend, Mule. Możliwości, które
oferowały wyglądały na obiecujące, ale zupełnie niepasujące do specyfiki naszego projektu. Jednym z celów naszej
platformy było opracowanie interfejsu, który pozwalałby na możliwie łatwe, automatyczne wpinanie i wypinanie
mikrousług. Nijak do tak postawionego celu miała się konieczność konfigurowania szyny danych przez panel wystawiony w sieci
WWW lub wręcz przy pomocy specjalnego środowiska programistycznego takiego jak Eclipse, z obowiązkową fazą kompilacji
i wgrywania na serwer. 

Rozwiązaniem wartym wspomnienia jest Zato, dość osobliwa szyna danych rozwijana przez osobę o polsko brzmiącym nazwisku. Jej głównymi cechami są skalowalność, możliwość rekonfiguracji w locie oraz bardzo dobra integracja z językiem python, co miało dla nas niebagatelne znaczenie na etapie wczesnych analiz. W zasadzie cała logika realizowana przez tę szynę danych mogła być zapisana w postaci skryptu pythona, co otwierało nas na zupełnie nowe możliwości integracji mikrousług. Rozważaliśmy scenariusz, w którym szyna danych odpowiadałaby za wykrywanie działających mikrousług, trzymanie ich spisu i metadanych z nimi powiązanych oraz rozgłaszanie tegoż spisu do warstwy prezentacji i innych mikrousług. Zrezygnowaliśmy z tego podejścia jako naruszającego zasadę separacji odpowiedzialności.

\subsection{Kolejki komunikatów}
Niepowodzenia przy poszukiwaniu odpowiadającej nam szyny danych skierowały nas w kierunku innych rozwiązań, takich jak
kolejki komunikatów. Głównym wymaganiem jakie postawiliśmy była bardzo duża odporność na różnego rodzaju błędy i
awarie. W idealnym modelu każda wiadomość w kolejce powinna mieć trzy stany: do przetworzenia, w trakcie przetwarzania, wykonany. Celem takiego modelu jest, by w przypadku awarii jednego serwera usługi jego zadanie było transparentnie przekazane serwerowi zastępczemu, bez przerywania operacji. Udało nam się znaleźć tylko jedną kolejkę spełniającą to wymaganie - Beanstalkd.

Innym sposobem osiągnięcia niezawodności może być kolejka ukryta wewnątrz mikrousługi, która w razie awarii jednego serwera pozwalałaby na odczytanie zadania przez inny serwer i dokończenie go. Niestety wtedy mogą mieć miejsce problemy z atomowością operacji. Przykładowo, w sytuacji gdy zadanie w kolejce zostało oznaczone jako wykonane, ale usługa wywołująca nie otrzymała jeszcze odpowiedzi nastąpi awaria wywoływanej mikrousługi, może dojść do duplikacji wykonanej operacji lub rozspójnienia danych.

\subsection{Dzienniki}

Jeszcze innym, ciekawym podejściem byłoby zastosowanie usługi udostępniającej niezawodny dostęp do czegoś w rodzaju dziennika. Wtedy moglibyśmy stosunkowo małym kosztem zaimplementować mechanizmy stosujące transakcyjność rodem z relacyjnych baz danych. Przykładami takich usług są DistributedLog i Kafka. Poszczególne mikrousługi monitorowałyby dziennik i z niego pobierały zmiany, a następnie reagowały na nie poprzez podjęcie jakiejś akcji. Można sobie wyobrazić dwa sposoby wykorzystania takiego dziennika. Pierwszy polegałby na tym, że wszystkie dokonane zmiany są atomowo publikowane w jednej dużej paczce, która musiałaby być potem rozpakowywana, a poszczególne zmiany wyłuskiwane. Drugim sposobem byłoby stworzenie dużej ilości dzienników na każdy rodzaj zdarzenia, a każda operacja byłaby wykonywana w małych krokach, w sposób potokowy.

\subsection{Rozwiązania oparte o BPMN}
W wymienionych wyżej modelach komunikacji serwery pośredniczące w wymianie
komunikatów nic nie wiedzą o procesach biznesowych, w których uczestniczą. 
Możliwa jest jednak realizacja zgoła przeciwnego podejścia, w którym działanie
wszystkich mikrousług jest koordynowane przez jedną centralną usługę.

Pozwalala ona na modelowanie procesów biznesowych przy pomocy graficznej
,,Notacji i Modelu Procesu Biznesowego'' (ang. \textit{Business Process Modeling
Notation}), a następnie wykonanie ich na specjalnie do tego celu skonstruowanym
silniku. Poszczególne mikrousługi stanowią w tym modelu ,,klocki'', z których
klient może sobie kontruować bardziej złożone procesy. Przykładami technologii,
które implementują wyżej wymienioną funkcjonalność są:
\begin{itemize}
	\item Camunda (oparty na Activiti)
	\item Bonita BPM
	\item jBPM
	\item Intalio BPMS
\end{itemize}

James Lewis i Martin Fowler w swojej publikacji \cite{fowlermicroservices}
stwierdzają, że powyższe podejście nie jest preferowane w środowisku mikrousług
gdyż stanowi złamanie zasady ,,sprytnych końcówek i bezmyślnych łączy'' (ang.
\textit{smart endpoints and dumb pipes}).

\section{Problemy z współbieżnością mikrousług}

Nietrudno wyobrazić sobie sytuację, w której dwie współbieżnie działające mikrousługi
wprowadzają konfliktujące ze sobą zmiany. Pewną formą zabezpieczenia przed takimi sytuacjami
mogłoby być rozwiązywanie konfliktów przez mikrousługę pośredniczącą w dostępie do bazy danych.
Taka mikrousługa stanowiłaby wtedy coś w rodzaju sekcji krytycznej, uniemożliwiającej jednoczesne zapisy
i niespójne odczyty (niezależnie od atomowości operacji na bazie danych). 
Niestety, takie podejście może nie wystarczać, np. w przypadku dwóch niezależnie działających usług, które wpierw
odczytują jakąś informację z bazy danych, a następnie na podstawie uzyskanej informacji wybierają rodzaj
akcji do podjęcia i nadpisują część bazy danych.

Jest kilka możliwych rozwiązań tego problemu. Możemy je pogrupować ze względu na następujące cechy:
\begin{itemize}
	\item miejsce przechowywania blokad
	\item sposób zakładania blokad na usługi
	\item wielkość obiektów, które będą blokowane
\end{itemize}
Blokady mogą być przechowywane w dedykowanej, wydzielonej mikrousłudze lub w mikrousłudze, której dotyczą. W naszej opinii
pierwsze podejście jest o tyle lepsze, że pozwala na wykrywanie zakleszczeń. Wadą takiego rozwiązania jest
stosunkowo słabe zrównoleglanie i fakt, że taka mikrousługa stanowiłaby najsłabszy punkt systemu, którego awaria
skutkowałaby zablokowaniem wszystkich pozostałych usług. Blokady mogą być zakładane pojedyńczo, w miarę
postępu transakcji lub na jej samym początku (w takim przypadku mikrousługa musi dokładnie wiedzieć, z jakich
zasobów ma zamiar skorzystać). Wydaje nam się, że najsensowniejszym wariantem jest wykorzystanie rozwiązań
stosowanych w relacyjnych bazach danych, gdzie blokady są zakładane w miarę postępu transakcji, a w przypadku
wykrycia zakleszczenia zmiany są wycofywane, sama zaś usługa wywłaszczana. Przy kolejnej próbie takiej mikrousłudze
nadany zostaje większy priorytet, który zapewnia żywotność. W przypadku implementacji takiego podejścia należy
pamiętać o zapewnieniu mechanizmów wywłaszczania mikrousług, księgowania zmian, śledzenia transakcji, wykrywania
zakleszczeń, nadawania priorytetów oraz o możliwości zakładania możliwie małych blokad na pojedyńcze rekordy.

Innym sposobem rozwiązania wyżej przedstawionego problemu jest zakładanie blokad na początku transakcji.
Ze względów wydajnościowych blokowanie przez muteks
całych mikrousług zapewniających dostęp do danych nie jest możliwe. Z uwagi na opóźnienia w przesyłaniu informacji
przez sieć prowadziłoby to z jednej strony do marnowania mocy obliczeniowej serwera bazy danych, a z drugiej strony
znacząco ograniczałoby ilość jednoczesnych operacji. Z kolei zakładanie blokad na konkretne wiersze w poszczególnych
mikrousługach jest nierealizowalne, gdyż w chwili zakładania muteksu usługa może nie wiedzieć, jakie konkretnie
wiersze zmodyfikuje. Uznaliśmy, że złotym środkiem jest zakładanie blokady na właściciela danych. Wynika to z
faktu, że w typowej urzędniczej praktyce wykonywane operacje dotyczą co najwyżej kilku osób.

Uzbrojeni w powyższe informacje wytypowaliśmy dwie usługi mogące działać jako zarządca rozproszonego muteksa:
redisson \cite{redisson} i ZooKeeper \cite{zookeeper}. Redisson jest rozwiązaniem implementującym algorytm Redlock
\cite{redislock}. Jego najważniejszą cechą jest odporność na awarie usług poprzez automatyczne zwalnianie blokady
po upływie określonego czasu. W internecie ukazała się bardzo interesująca polemika do przytoczonego algorytmu \cite{redisbad}.
Głównym zarzutem czynionym wobec algorytmu Redlock jest brak mechanizmu, który zapobiegałby następującej sytuacji:
mikrousługa A zakłada blokadę na zasób Z. Następnie zaczyna operację nadpisywania danych. W trakcie operacji
działanie mikrousługi z losowego powodu zostaje zawieszone (np. wystąpiło znaczne opóźnienie w połączeniu sieciowym
lub włączył się odśmiecacz pamięci). W tym czasie termin ważności blokady mija, zostaje ona zdjęta, a do akcji
wkracza mikrousługa B, która zakłada swoją blokadę, nadpisuje dane utworzone przez usługę A i kończy swoje
działanie. Na koniec usługa A zostaje wybudzona i kontynuuje swoje działanie, prowadząc do rozspójnienia danych.
Według autora polemiki rozwiązaniem tego problemu jest skorzystanie z mechanizmu współdzielonej blokady
zaimplementowanej w frameworku Apache Curator \cite{curatorlock} i korzystającej pod spodem z Apache ZooKeepera.
Jest to bezpieczniejsze rozwiązanie które nie pozwala na wygaśnięcie blokady z powodu upływającego
czasu, a w przypadku awarii mikrousługi i utraty połączenia z nią
automatycznie zdejmuje blokadę. Ponadto, jest to stosunkowo nowoczesny projekt wykorzystywany i rozwijany przez
duże firmy takie jak Netflix, co daje pewne nadzieje dotyczące stabilności i dojrzałości tego projektu.

\section{Rejestracja i wykrywanie mikrousług}
TODO przerobić na ogólny tekst

Najbliższy naszym potrzebom był serwer Apache ZooKeeper \cite{zookeeper} w
połączeniu z biblioteką Apache Curator \cite{curator}. Dane na serwerze
ZooKeeper są trzymane w drzewiastej strukturze. Każdy węzeł może zawierać dowolny
ciąg bajtów ograniczony do rozmiaru ok. 1 Mb. Węzły są wersjonowane, a dostęp
do nich jest kontrolowany przez mechanizm ACL. Na każdym węźle można ustawić
obserwatora (ang. \textit{watch}), który w przypadku jakiejkolwiek modyfikacji
węzła powiadamia klienta o zmianie. Oprócz tego, każdy węzeł może mieć ustawione
dwie dodatkowe flagi. Pierwsza to \textit{ephemeral}, która oznacza, że węzeł ma
istnieć tylko do czasu zakończenia sesji klienta, który utworzył dany węzeł.
Ta własność jest szczególnie interesująca w kontekście automatycznego
wyrejestrowywania usługi która kończy swe działanie i nie ma możliwości
powiadomienia serwera o tym fakcie. Druga flaga to \textit{sequence}. Mówi ona,
że należy do nazwy tworzonego węzła dopisać rosnący numer. Ma to zastosowanie we
wszelkiego rodzaju kolejkach, algorytmach synchronizujących i przy wyborze
lidera \cite{curatorlock}. Biblioteka Curator upraszcza wiele aspektów związanych
z wykorzystaniem ZooKeepera, między innymi rejestrację serwerów mikrousług,
zapewnia implementację najczęściej wykorzystywanych algorytmów synchronizujących
oraz łatwe buforowanie drzewa węzłów wraz z automatycznym pobieraniem zmian.

Rozwiązaniem bardzo podobnym do ZooKeepera jest Consul. Zasadniczą różnicą
między tymi dwoma serwerami było zastosowanie w Consulu słownika typu
klucz-wartość oraz znacznie bardziej zaawansowane raportowanie stanu
mikrousługi, które obejmowało nie tylko informację o działaniu serwera usługi,
ale także okresowe sprawdzanie jego stanu przy pomocy specjalnie
zaprojektowanego RESTowego interfejsu. Ułatwiał on integrację z platformami na
których nie był dostępny klient Consula.

Podobną, chociaż nieco okrojoną funkcjonalność w stosunku do Consula zapełniały
serwery etcd i Netflix Eureka. Ten pierwszy pozwalał na rozproszone składowanie
danych w słowniku typu klucz-wartość. Eureka z kolei zapewniała automatyczną
rejestrację, wykrywanie i odpytywanie mikrousług z zadaną częstotliwością oraz
monitorowanie ich stanu.

\section{Konkluzje}
TODO

% odnośnie tego powyżej:
Jest jeszcze jeden problem, na który użytkownicy naszej platformy mogą się natknąć. Mianowicie, nasza platforma
może integrować poprzez różne adaptery już istniejące usługi, które zupełnie nie są świadome istnienia
zaproponowanego mechanizmu blokad, więc nie są odporne na błędy wynikające z współbieżności.
Projektanci mikrousług korzystających z naszej platformy muszą być świadomi wszystkiego, co wyżej napisano.
Aby maksymalnie ułatwić im pracę uwzględniliśmy wyniki powyższych rozważań przy projektowaniu API, jednak nie
jesteśmy w stanie rozwiązać wszystkich pojawiających się problemów.

\chapter{Wymagania}

Zdecydowaliśmy się przenieść środek ciężkości naszego projektu w stronę warstwy integracji klienta z backendem. Ustalono, że do osiągnięcia sukcesu wystarczy spełnienie następujących warunków: %TODO
\begin{itemize}
	\item Zrobicie warstwę FE + BFF w ten sposób, że zostanie zrobione środowisko Web Style Guide z podstawowymi i złożonymi kontrolkami oraz z generacją kodu.
	\item Następnie użytkownik będzie mógł sam wyklikać kontrolki i ustawić to w dashboardy.
	\item Na końcu chciałbym mięc zrobiony mockup pue.zus.pl wyklikany w ten sposób.
\end{itemize}

\section{Interfejs użytkownika}
TODO

Tego chcemy uniknąć:\\
\includegraphics[width=\textwidth]{obrazki/logowaniezle.jpg}


\chapter{Wykorzystane technologie}

\section{Języki programowania}
Python, Java, Node.js, typescript

\section{Angular 2}

Do tworzenia cześć wizualnej oraz logiki bezpośrednio z nią związanej, użyliśmy frameworka Angular2. Jest to narzędzie stworzone przez Google, opierające się
na Type Script - języku będącym nadzbiorem Java Script. W stosunku do js główną funkcjonalnością ts jest dodanie obiektowości, jednakże można stwierdzić,
że wszystko co związane z obiektowością w ts to tylko lukier syntaktyczny, ponieważ w ts koniec konców jest przetłumaczony do czystego js. Ts implementuje większość
funkcjonalności, które język obiektowy powinien oferować - możliwe jest dziedziczenie, tworzenie interfesjów, konstruktory itp. Ciekawą opcją są dekoratory, czyli
odzobniki klas. Dekoratory (szerzej opisane w dalszej części pracy) pozwalają na zmianą ``zachowania'' klasy już w trakcie kompilacji.

\section{Bootstrap}

Za wygląd strony odpowiada HTML5, połączony z Bootstrapem. Bootstrap to zbiór gotowych komponentów wizulanych, pozwalający, bez zbędnego wnikania
w stronę ``artystyczną'', tworzyć strony estetyczne oraz wygodne w użyciu. Jako, że tematem naszej pracy nie jest projektowanie stron internetowych,
użyliśmy gotowej skórki - sbAdmin2. Właściwie, lepszym określeniem, jest użycie sbAdmin2 jako punktu wyjścia, ponieważ liczba wprowadzliśmy
liczne zmiany w wyglądzie platformy.

\section{Express.js}

\section{ZooKeeper}

Jednym z elementów wizji naszego systemu był fakt, że poszczególne usługi
powinny możliwie prosto ,,wpinać się'' w system. Serwer mikrousługi w trakcie
uruchamiania dopisywałby do globalnej konfiguracji wpisy związane z prowadzoną
przez siebie działalnością, takie jak adresy pod którymi przyjmuje zapytania
albo pozycje w menu widocznym dla użytkownika, które prowadzą do poszczególnych
usług biznesowych. Doszliśmy do wniosku, że nasze oczekiwania można sprowadzić
do trzech wymagań:
\begin{itemize}
	\item przechowywania konfiguracji w drzewiastej strukturze
	\item automatycznego usuwania dokładnie określonych wpisów w przypadku
	utraty dowolnego serwera mikrousługi
	\item automatyczną replikację danych
\end{itemize}

Najbliższy naszym potrzebom był serwer Apache ZooKeeper \cite{zookeeper} w
połączeniu z biblioteką Apache Curator \cite{curator}. Dane na serwerze
ZooKeeper są trzymane w drzewiastej strukturze. Każdy węzeł może zawierać dowolny
ciąg bajtów ograniczony do rozmiaru ok. 1 Mb. Węzły są wersjonowane, a dostęp
do nich jest kontrolowany przez mechanizm ACL. Na każdym węźle można ustawić
obserwatora (ang. \textit{watch}), który w przypadku jakiejkolwiek modyfikacji
węzła powiadamia klienta o zmianie. Oprócz tego, każdy węzeł może mieć ustawione
dwie dodatkowe flagi. Pierwsza to \textit{ephemeral}, która oznacza, że węzeł ma
istnieć tylko do czasu zakończenia sesji klienta, który utworzył dany węzeł.
Ta własność jest szczególnie interesująca w kontekście automatycznego
wyrejestrowywania usługi która kończy swe działanie i nie ma możliwości
powiadomienia serwera o tym fakcie. Druga flaga to \textit{sequence}. Mówi ona,
że należy do nazwy tworzonego węzła dopisać rosnący numer. Ma to zastosowanie we
wszelkiego rodzaju kolejkach, algorytmach synchronizujących i przy wyborze
lidera \cite{curatorlock}.

\subsection{Curator}
Biblioteka Curator upraszcza wiele aspektów związanych
z wykorzystaniem ZooKeepera, między innymi rejestrację serwerów mikrousług,
zapewnia implementację najczęściej wykorzystywanych algorytmów synchronizujących
oraz łatwe buforowanie drzewa węzłów wraz z automatycznym pobieraniem zmian. W
trakcie prac nad integratorem okazało się, że oferowane możliwości znacznie przekraczają
nasze potrzeby.

\subsection{Kazoo}
Zk dla pythona

\section{Django}

\section{Play Framework}

\section{GRPC}

\section{SQLite}

W naszym projekcie rodzaj użytej bazy danych nie miał większego znaczenia, gdyż
dostęp do niej odbywa się poprzez wyspecjalizowaną usługę zapewniającą dostęp do
danych lub w ramach jednej mikrousługi, gdzie służy jako tymczasowe składowisko
informacji potrzebnych przy wykonywaniu operacji. W takim modelu rodzaj użytej
bazy danych jest transparentny dla usługi wywołującej. Z uwagi na prototypowy
charakter naszego projektu poprzestaliśmy na bazie SQLite, jako że znakomicie
integruje się ona z Django, ponadto zastąpienie jej PostgreSQLem jest
praktycznie bezkosztowe.

\chapter{Realizacja}

\section{Architektura aplikacji}

\subsection{Frontend}

\subsection{Integrator}
Integrator - autodiscovery usług, możliwość spinania różnych interfejsów gRPC, WSDL. 
Z uwagi na to, że dane przechodzą przez niego w postaci nieszyfrowanej można
go podłączyć do IDSa wykrywającego anomalie w przesyłanych danych i w ten sposób
zapobiegać masowemu wyciekowi wrażliwych danych lub atakom hakerskim. Stanowi też
dodatkową linię obrony, którą musi sforsować potencjalny haker. Dzięki temu system jest
odporniejszy na błędy popełnione w serwerach mikrousług, a w przypadku wykrycia
jakiejś luki można ad-hoc wprowadzić łatkę bezpieczeństwa w serwerze pośredniczącym
zamiast łatać wszystkie podatne serwery mikrousług.

\subsection{Mikrousługi}
TODO

\section{Frontend}

\subsection{Tworzenie mockupów}
Tutaj opis wszystkich stworzonych podstron
\subsection{Stworznie systemu komponentów}
Opis posczególnych komponentów, oraz całej idei architektury tego rozwiązania.
\subsection{System tworzenia automatycznej dokumentacji}
Opis dekoratorów.
\subsection{Edytor}
TODO
\subsection{Platforma developera}
Sposób dodawania mikrosusług, style guide.

\section{Integrator}

\section{Mikrousługi}

\chapter{Obserwator emerytalny}
Z uwagi na bardzo niepewny charakter naszego projektu i trudności związane z
formalnym rozliczeniem naszej pracy zdecydowaliśmy się wykonać niejako poza
głównym projektem serwis ,,Obserwator emerytalny''.

\chapter{Wkład poszczególnych członków zespołu w projekt}\label{r:wklad}
TODO
\appendix
\chapter{Spis zawartości dołączonej płyty CD}\label{r:spis}
Dokładny spis zawartości towarzyszącej płytki (p. dalej). To bardzo ważne, proszę zapisać jako osobny rozdział (czyli np. nie podrozdział). Płytka CD/DVD/Blu-ray/...

Zawiera:\\
Pełną dokumentacją projektu w łatwo dającym się odczytać formacie (najlepiej pdf + źródło).
Program (w postaci źródłowej i potencjalnie umożliwiającej uruchomienie, to może oznaczać np. dostarczenie stosownych plików makefile, pomocniczych plików z danymi, opisu instalacji itp.).
Wszelkie inne dokumenty powstałe podczas zajęć (np. teksty prezentacji, teksty pracy z poprzedniego dużego punktu, itp.).

Płyta jest częścią pracy - trzeba tyle płyt co drukowanych egzemplarzy pracy. Płytkę trzeba przymocować do pracy, tak by a) nie wypadała b) dało się ją wyjąć i odczytać w komputerze :).

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem[DOZ]{zusdoz} ZUS, \textit{Dokumentowanie okresów zatrudnienia oraz
	wynagrodzenia}, http://www.zus.pl/files/Dokumentowanie\_okres\%C3\%B3w\_zatrudnienia.pdf

\bibitem[TFA]{tfa} Autor nieznany, \textit{The Twelve-Factor App}, https://12factor.net/

\bibitem[SDM]{govsm} Autor nieznany, \textit{Government Service Design Manual},
https://www.gov.uk/service-manual/index.html

\bibitem[MSV]{microsvc} Chris Richardson, \textit{Microservice architecture patterns and best practices},
http://microservices.io/

\bibitem[MCO]{mcobywatel} Ministerstwo Cyfryzacji, \textit{Portal Rzeczypospolitej Polskiej - Opis projektu},
https://mc.gov.pl/projekty/portal-rzeczypospolitej-polskiej/opis-projektu

\bibitem[PUE]{zuspue} ZUS, \textit{Platforma Usług Elektronicznych},
http://pue.zus.pl/

\bibitem[RDL]{redislock} Redis, \textit{Distributed locks with Redis},
https://redis.io/topics/distlock

\bibitem[RDS]{redisson} \textit{Redisson},
http://redisson.org/

\bibitem[AZK]{zookeeper} Apache, \textit{Apache ZooKeeper},
https://zookeeper.apache.org/

\bibitem[ACU]{curator} Apache, \textit{Apache Curator},
http://curator.apache.org/

\bibitem[HTL]{redisbad} Martin Kleppmann, \textit{How to do distributed locking},
http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

\bibitem[CLK]{curatorlock} Apache, \textit{Apache Curator - Shared Lock},
http://curator.apache.org/curator-recipes/shared-lock.html

\bibitem[Fowler]{fowlermicroservices} James Lewis, Martin Fowler, \textit{Microservices},
https://martinfowler.com/articles/microservices.html

\bibitem[RSUS]{rocznik} ZUS, \textit{Rocznik Statystyczny Ubezpieczeń Społecznych},
http://www.zus.pl/documents/10182/167642/Rocznik+Statystyczny+Ubezpiecze\%C5\%84+Spo\%C5\%82ecznych+2009-2011/7e6fcc34-8333-4af0-b3e6-9e64ea734600

\end{thebibliography}

\end{document}
